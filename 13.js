/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/Sequencer.ts":
/*!**************************!*\
  !*** ./src/Sequencer.ts ***!
  \**************************/
/*! exports provided: ac, Sequence, intervalsToMelody, partLead, partHarmony, partBass, getBeatIndex, getBeatLength, getStartOfNextBar */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ac\", function() { return ac; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Sequence\", function() { return Sequence; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"intervalsToMelody\", function() { return intervalsToMelody; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"partLead\", function() { return partLead; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"partHarmony\", function() { return partHarmony; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"partBass\", function() { return partBass; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getBeatIndex\", function() { return getBeatIndex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getBeatLength\", function() { return getBeatLength; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getStartOfNextBar\", function() { return getStartOfNextBar; });\n/* harmony import */ var _music__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./music */ \"./src/music.ts\");\n\nconst ac = new AudioContext();\nconst delay = ac.createDelay(4);\ndelay.delayTime.value = (60 / 120 / 4); //quarter note at 120bpm\ndelay.connect(ac.destination);\nfunction Note(freq, duration) {\n    return [freq, duration];\n}\nfunction Sequence(tempo, notes = []) {\n    this.ac = ac;\n    this.createFxNodes();\n    this.tempo = tempo || 120;\n    this.loop = true;\n    this.smoothing = 0;\n    this.staccato = 0;\n    this.notes = notes;\n}\n// create gain and EQ nodes, then connect 'em\nSequence.prototype.createFxNodes = function () {\n    const eq = [['bass', 100], ['mid', 1000], ['treble', 2500]];\n    let prev = this.gain = this.ac.createGain();\n    eq.forEach(function (config, fx) {\n        fx = this[config[0]] = this.ac.createBiquadFilter();\n        fx.type = 'peaking';\n        fx.frequency.value = config[1];\n        prev.connect(prev = fx);\n    }.bind(this));\n    this.lp = this.ac.createBiquadFilter();\n    this.lp.type = 'lowpass';\n    this.lp.frequency.value = 15000;\n    prev.connect(prev = this.lp);\n    this.hp = this.ac.createBiquadFilter();\n    this.hp.type = 'highpass';\n    this.hp.frequency.value = 80;\n    prev.connect(prev = this.hp);\n    prev.connect(this.ac.destination);\n    return this;\n};\n// recreate the oscillator node (happens on every play)\nSequence.prototype.createOscillator = function () {\n    this.stop();\n    this.osc = this.ac.createOscillator();\n    this.osc.type = this.waveType || 'square';\n    this.gain.value = 0.1;\n    if (this.type == 'lead') {\n        this.osc.connect(delay);\n        this.osc.connect(this.ac.destination);\n        this.osc.connect(this.ac.destination);\n    }\n    this.osc.connect(this.gain);\n    return this;\n};\n// schedules this.notes[ index ] to play at the given time\n// returns an AudioContext timestamp of when the note will *end*\nSequence.prototype.scheduleNote = function (index, when) {\n    const duration = 60 / this.tempo * this.notes[index][1], cutoff = duration * (1 - (this.staccato || 0));\n    this.setFrequency(this.notes[index][0], when);\n    if (this.smoothing && this.notes[index][0]) {\n        this.slide(index, when, cutoff);\n    }\n    this.setFrequency(0, when + cutoff);\n    return when + duration;\n};\n// get the next note\nSequence.prototype.getNextNote = function (index) {\n    return this.notes[index < this.notes.length - 1 ? index + 1 : 0];\n};\n// how long do we wait before beginning the slide? (in seconds)\nSequence.prototype.getSlideStartDelay = function (duration) {\n    return duration - Math.min(duration, 60 / this.tempo * this.smoothing);\n};\n// slide the note at <index> into the next note at the given time,\n// and apply staccato effect if needed\nSequence.prototype.slide = function (index, when, cutoff) {\n    const next = this.getNextNote(index), start = this.getSlideStartDelay(cutoff);\n    this.setFrequency(this.notes[index][0], when + start);\n    this.rampFrequency(next[0], when + cutoff);\n    return this;\n};\nSequence.prototype.setFrequency = function (freq, when) {\n    this.osc.frequency.setValueAtTime(freq, when);\n    return this;\n};\nSequence.prototype.rampFrequency = function (freq, when) {\n    this.osc.frequency.linearRampToValueAtTime(freq, when);\n    return this;\n};\n// run through all notes in the sequence and schedule them\nSequence.prototype.play = function (when) {\n    when = typeof when === 'number' ? when : this.ac.currentTime;\n    this.createOscillator();\n    this.osc.start(when + 1);\n    this.notes.forEach(function (note, i) {\n        when = this.scheduleNote(i, when);\n    }.bind(this));\n    this.osc.stop(when);\n    return this;\n};\n// stop playback, null out the oscillator, cancel parameter automation\nSequence.prototype.stop = function () {\n    if (this.osc) {\n        this.osc.stop(0);\n        this.osc.frequency.cancelScheduledValues(0);\n        this.osc = null;\n    }\n    return this;\n};\nconst intervalsToMelody = (root, duration = (i) => 1, intervals = []) => intervals.map((interval, i) => ([isNaN(interval) ? 0 : Object(_music__WEBPACK_IMPORTED_MODULE_0__[\"transpose\"])(root, interval), duration(i)]));\nconst partLead = (when, tempo, melody) => {\n    const seq = new Sequence(tempo, melody);\n    seq.staccato = 0.55;\n    seq.gain.gain.value = 1.0;\n    seq.bass.frequency.value = 400;\n    seq.bass.gain.value = -4;\n    seq.mid.frequency.value = 800;\n    seq.mid.gain.value = 3;\n    seq.waveType = 'square';\n    seq.hp.frequency.value = 1200;\n    seq.role = 'lead';\n    return function play() {\n        seq.play(when);\n        return seq;\n    };\n};\nconst partHarmony = (when, tempo, melody) => {\n    const seq = new Sequence(tempo, melody);\n    seq.mid.frequency.value = 1200;\n    seq.gain.gain.value = 0.8;\n    seq.staccato = 0.55;\n    seq.waveType = 'triangle';\n    return function play() {\n        seq.play(when);\n        return seq;\n    };\n};\nconst partBass = (when, tempo, melody) => {\n    const seq = new Sequence(tempo, melody);\n    seq.staccato = 0.05;\n    seq.smoothing = 0.05;\n    seq.gain.gain.value = 0.65;\n    seq.mid.gain.value = 3;\n    seq.bass.gain.value = 6;\n    seq.bass.frequency.value = 80;\n    seq.mid.gain.value = -2;\n    seq.mid.frequency.value = 500;\n    seq.treble.gain.value = -4;\n    seq.treble.frequency.value = 1400;\n    seq.waveType = 'square';\n    return function play() {\n        seq.play(when);\n        return seq;\n    };\n};\nfunction getBeatIndex(time, bpm, notes = []) {\n    const beatDuration = getBeatLength(bpm);\n    const barDuration = beatDuration * notes.length;\n    const location = time % barDuration;\n    return notes.findIndex((note, i) => location <= ((i + 1) * beatDuration));\n}\nfunction getBeatLength(bpm) {\n    return (60 / bpm);\n}\nfunction getStartOfNextBar(time, bpm, notes) {\n    let currentIndex = getBeatIndex(time, bpm, notes);\n    const beatWidth = getBeatLength(bpm);\n}\n\n\n//# sourceURL=webpack:///./src/Sequencer.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./store */ \"./src/store.ts\");\n/* harmony import */ var _Sequencer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Sequencer */ \"./src/Sequencer.ts\");\n\n\nconst { abs, sin, cos, pow, sqrt, floor, ceil, random, PI, max, min } = Math;\nvar Role;\n(function (Role) {\n    Role[Role[\"bass\"] = 0] = \"bass\";\n    Role[Role[\"tenor\"] = 1] = \"tenor\";\n    Role[Role[\"alto\"] = 2] = \"alto\";\n    Role[Role[\"soprano\"] = 3] = \"soprano\";\n})(Role || (Role = {}));\nvar Clan;\n(function (Clan) {\n    Clan[Clan[\"Blue\"] = 0] = \"Blue\";\n    Clan[Clan[\"Red\"] = 1] = \"Red\";\n    Clan[Clan[\"Yellow\"] = 2] = \"Yellow\";\n})(Clan || (Clan = {}));\n// # Game Data \nconst clanAttributes = { [Clan.Red]: { rgb: [255, 0, 0]\n    },\n    [Clan.Blue]: { rgb: [0, 0, 255]\n    },\n    [Clan.Yellow]: { rgb: [0, 255, 0]\n    }\n};\nconst roleAttributes = { [Role.bass]: { colorMod(n, time) { return n == 255 ? 50 : n; },\n        text: '#'\n    },\n    [Role.tenor]: { colorMod(n, time) { return n == 255 ? 100 : n; },\n        text: '\\\\-'\n    },\n    [Role.alto]: { colorMod(n, time) { return n == 255 ? 175 : n; },\n        text: '=/'\n    },\n    [Role.soprano]: { colorMod(n, time) { return 255; },\n        text: '@' }\n};\nconst Presets = { [Clan.Yellow]: { tonic: 88,\n        bpm: 70,\n        voices: { [Role.bass]: [0, 5, 0, 7],\n            [Role.tenor]: [0, 5, NaN, 5],\n            [Role.alto]: [7, 2, NaN],\n            [Role.soprano]: [12, 4, NaN, 12, 7, NaN, 4, 7]\n        }\n    },\n    [Clan.Red]: { tonic: 52,\n        bpm: 93.333,\n        voices: { [Role.bass]: [7, 0],\n            [Role.tenor]: [4, 4, 2, 4],\n            [Role.alto]: [7, 4, 7, NaN],\n            [Role.soprano]: [12, NaN, NaN, 0]\n        }\n    },\n    [Clan.Blue]: { tonic: 128,\n        bpm: 124.44 / 2,\n        voices: { [Role.bass]: [12, 0, NaN, 0],\n            [Role.tenor]: [0, 4, 0],\n            [Role.alto]: [7, NaN, 12],\n            [Role.soprano]: [4, NaN, NaN, 12, 7, 4, 7, NaN]\n        }\n    }\n};\nconst Songs = { \"opening\": { tonic: 84,\n        bpm: 132,\n        voices: { [Role.bass]: [0, NaN, 0, 3, 0, NaN, 0, 4, 0, NaN, 0, 7, 9, 5, 7, 2],\n            [Role.tenor]: [3, 3, 3, 3, 4, 4, 4, 4, 7, 7, 7, 7, 10, 10, 10, 10],\n            [Role.alto]: [NaN, 5, NaN, 5, NaN, 7, NaN, 7, NaN, 2, NaN, 2, NaN, 5, NaN, 5],\n            [Role.soprano]: [10, NaN, NaN, NaN, 11, NaN, NaN, NaN, NaN, 11, NaN, NaN, NaN, NaN, 10, NaN, NaN, NaN, NaN,]\n        }\n    }\n};\nconst mods = [(t, state) => floor(downScale(t, (state.level * 2) + 5) % 255),\n    (t, state) => floor(downScale(t, 51 + state.level) % 255),\n    (t, state) => floor(downScale(t, 91 - state.level) % 255),\n    (t, state) => floor(t + 223 % 20)];\nconst useMod = (n, time, state) => mods[n % mods.length](time, state);\nconst collides = (unit, obj) => {\n    if (unit.objectID == obj.objectID)\n        return false;\n    return !(unit.x > obj.x + obj.width ||\n        unit.x + obj.width < obj.x ||\n        unit.y > obj.y + obj.height ||\n        unit.y + obj.height < obj.y);\n};\nconst applyDroneDamage = (role, ensemble) => {\n    const next = Object.assign({}, ensemble);\n    const mirrors = [[Role.bass, Role.soprano],\n        [Role.tenor, Role.alto]];\n    let dmg = 0;\n    for (let duo of mirrors) {\n        if (duo.includes(role)) {\n            dmg = (duo[0] == role)\n                ? 1\n                : 2;\n            next[role].volume = next[role].volume - dmg;\n        }\n    }\n    return next;\n};\nconst touchHandlers = { drone(state, touches) {\n        const ensemble = touches.reduce((ensemble, drone) => applyDroneDamage(state.room.role, state.ensemble), touches);\n        const defenderIDs = touches.map(drone => drone.objectID);\n        // destroy on contact\n        const drones = state.drones.filter(drone => !defenderIDs.includes(drone.objectID));\n        return Object.assign(Object.assign({}, state), { drones, ensemble });\n    },\n    element(state, touches) {\n        if (state.level == 0 && touches.length > 1) {\n            // prevent multiple collisions when there are 3 nodes\n            return state;\n        }\n        const element = touches[0];\n        const room = { clan: element.clan,\n            role: (state.level == 0) ? Role.bass : element.role };\n        const ensemble = addToEnsemble(state.ensemble, room.clan, room.role);\n        return (Object.assign(Object.assign({}, state), { ensemble,\n            room, drops: [], level: state.level + 1 }));\n    }\n};\nconst canvasWidth = window.innerWidth;\nconst canvasHeight = window.innerHeight;\nconst playerHeight = 80;\nconst playerWidth = 80;\nconst droneWidth = 50;\nconst droneHeight = 50;\nconst elementRadius = min(100, canvasWidth / 6);\nconst config = {\n    canvasWidth,\n    canvasHeight\n};\nconst objectID = () => {\n    return objectID.prev++;\n};\nobjectID.prev = 0;\nconst downScale = (n, scale = 3) => n * pow(10, -(scale));\nconst throttle = (seconds = 2) => setTimeout(() => { debugger; }, seconds * 1000);\nconst aN = n => (!isNaN(n) && typeof n == 'number');\nconst toColor = (rgb, mod = (n, time) => n) => {\n    if (rgb.length != 3) {\n        return '';\n    }\n    const [r, g, b] = rgb.map(mod).map(n => n.toString());\n    return `rgb(${r},${g},${b})`;\n};\nconst randomInt = (min = 0, max = 1) => floor(random() * (floor(max) - ceil(min) + 1)) + ceil(min);\nconst log = (...any) => console.log(any);\nconst coinToss = () => (Math.random() < 0.5);\nconst isNearWall = (u, threshold = 0.1) => (u.x <= canvasWidth * threshold) && (u.y <= canvasHeight * threshold);\nconst walk = (u, step = 1) => {\n    let direction = u.lastwalk ? 'x' : 'y';\n    return (Object.assign(Object.assign({}, u), { lastwalk: !u.lastwalk, [direction]: coinToss() ? u[direction] + 1 : u[direction] - 1 }));\n};\nconst moveLeft = (u, amt = 7) => (Object.assign(Object.assign({}, u), { x: u.x > 0 ? u.x -= amt : 0 }));\nconst moveRight = (u, amt = 7) => (Object.assign(Object.assign({}, u), { x: u.x < (canvasWidth - playerWidth) ? u.x += amt : (canvasWidth - playerWidth) }));\nconst moveUp = (u, amt = 7) => (Object.assign(Object.assign({}, u), { y: u.y >= (0) ? u.y -= amt : playerHeight }));\nconst moveDown = (u, amt = 7) => (Object.assign(Object.assign({}, u), { y: u.y <= (canvasHeight) ? u.y += amt : (canvasHeight) }));\nconst createShot = (opts = {}) => {\n    return (Object.assign({ objectID: objectID(), name: 'shot', x: 0, y: 0, radius: 0, dr: (time, shot, index) => {\n            const maxRadius = floor(canvasWidth / 3);\n            const progress = (+new Date - shot.start) / (shot.duration);\n            if (progress > 1) {\n                return 0;\n            }\n            return floor(maxRadius * progress);\n        }, start: (+new Date), duration: 2000 }, opts));\n};\nconst createPlayer = () => {\n    return ({ objectID: objectID(),\n        name: 'player',\n        width: playerWidth,\n        height: playerHeight,\n        x: (canvasWidth) / 2,\n        y: canvasHeight / 5,\n        volume: 100,\n        speed: 100,\n        luck: 100\n    });\n};\nconst createDrone = (defaults = {}) => {\n    const bias = 0.7; // favor the center of the room\n    return Object.assign({ objectID: objectID(),\n        name: 'drone',\n        x: bias * Math.random() * canvasWidth,\n        y: bias * Math.random() * canvasHeight,\n        width: 40,\n        height: 40,\n        lastwalk: false\n    }, defaults);\n};\nconst createOpeningMusicDrops = (qty = 3) => {\n    const drops = [];\n    const containerWidth = canvasWidth * 2 / qty;\n    const offsetWall = canvasWidth / qty;\n    const offsetCeiling = (canvasHeight + elementRadius) / 2;\n    const elWidth = containerWidth / qty;\n    for (let i = 0; i < 3; i++) {\n        const x = offsetWall + (i * elWidth);\n        const y = offsetCeiling;\n        drops.push(createMusicDrop({ x, y, role: Role.bass, clan: Clan[Clan[i]] }));\n    }\n    return drops;\n};\nconst createMusicDrop = (opts = {}) => {\n    return (Object.assign(Object.assign({ clan: '', x: 0, y: 0, radius: elementRadius, dr: (time, element) => floor(elementRadius * abs(sin((element.objectID) + downScale(time)))), width: 0, height: 0 }, opts // do not allow name or objectID to be initialized\n    ), { name: 'element', objectID: objectID() }));\n};\nconst motionControls = () => ({ ArrowRight: moveRight,\n    ArrowLeft: moveLeft,\n    ArrowDown: moveDown,\n    ArrowUp: moveUp\n});\nconst applyMotion = (player, controlKey) => {\n    let map = motionControls();\n    if (!(Object.keys(map).includes(controlKey)))\n        return player;\n    return map[controlKey](player);\n};\n/* Respond to the keydown controls */\nconst applyControls = (time, state) => {\n    const renderOffset = 0;\n    let shots = state.shots;\n    if (game.controls.includes('f')) {\n        shots = shots.concat(createShot({ start: (+new Date), x: state.player.x, y: state.player.y, duration: 200 }));\n        game.controls = game.controls.filter(k => k != 'f');\n    }\n    const isInProgress = (shot) => 1 !== (floor((+new Date) / (shot.start + (shot.duration + renderOffset))));\n    return (Object.assign(Object.assign({}, state), { shots: shots.filter(isInProgress), player: game.controls.reduce(applyMotion, state.player) }));\n};\nconst updateRadial = (unit, time) => {\n    const radius = unit.dr(time, unit);\n    return Object.assign(Object.assign({}, unit), { radius, width: radius / 2, height: radius / 2 });\n};\n/* Update the x,y,width,height,radius properties of units in state. */\nconst applyPositions = (time, state) => {\n    return Object.assign(Object.assign({}, state), { shots: state.shots.map((u) => updateRadial(u, +new Date)), drops: state.drops.map((u) => updateRadial(u, time)), drones: state.drones.map(walk) });\n};\nconst applyToTree = (tree, u) => {\n    tree.insert(u);\n    return tree;\n};\n/* Global handler for store state updates */\nconst updateTreeIndices = (time, state, tree) => {\n    return ([state.player,\n        ...state.drones,\n        ...state.drops,\n        ...state.shots]).reduce(applyToTree, tree);\n};\nconst handlePlayerCollisions = (state, tree) => {\n    const droneHits = state.drones.reduce((collisions, drone) => {\n        const intersections = tree.retrieve(drone).filter((unit) => collides(unit, drone));\n        return collisions.concat(intersections);\n    }, []);\n    const playerHits = tree.retrieve(state.player).filter((u) => collides(u, state.player));\n    return [...playerHits, ...droneHits];\n};\nconst applyShotCollisions = (state, tree) => {\n    const allTouches = state.shots.map(shot => tree.retrieve(shot));\n    const touches = allTouches.reduce((a, x) => [...a, ...x], []);\n    const defenderIDs = touches.map(drone => drone.objectID);\n    // destroy on contact\n    const drones = state.drones.filter(drone => !defenderIDs.includes(drone.objectID));\n    return Object.assign(Object.assign({}, state), { drones });\n};\nconst addToEnsemble = (ensemble, clan, key, amt = 2) => {\n    if (ensemble[key].clan != clan) {\n        const preset = Presets[clan];\n        // Swap the previous type with the new one\n        ensemble[key].clan = clan;\n        ensemble[key].volume = amt;\n        ensemble[key].bpm = preset.bpm;\n        ensemble[key].tonic = preset.tonic;\n        ensemble[key].melody = preset.voices[key];\n    }\n    else {\n        ensemble[key].volume += amt;\n    }\n    return ensemble;\n};\nfunction getSynth(role) {\n    const roles = { [Role.bass]: _Sequencer__WEBPACK_IMPORTED_MODULE_1__[\"partBass\"],\n        [Role.tenor]: _Sequencer__WEBPACK_IMPORTED_MODULE_1__[\"partHarmony\"],\n        [Role.alto]: _Sequencer__WEBPACK_IMPORTED_MODULE_1__[\"partLead\"],\n        [Role.soprano]: _Sequencer__WEBPACK_IMPORTED_MODULE_1__[\"partHarmony\"]\n    };\n    return (roles[role] || _Sequencer__WEBPACK_IMPORTED_MODULE_1__[\"partHarmony\"]);\n}\n// reindexes the list to start at `index`\nfunction beatmatch(index, list) {\n    return [...list.concat().slice(index, list.length), ...list.concat().slice(0, index)];\n}\nconst choppy = x => 0.5;\nconst shortening = x => {\n    let duration = 1 / (x + 1);\n    return duration;\n};\nconst tenuto = x => 0.85;\nconst sostenuto = x => 0.99;\nconst getDuration = (role) => {\n    const roles = { [Role.bass]: choppy,\n        [Role.tenor]: tenuto,\n        [Role.alto]: shortening,\n        [Role.soprano]: sostenuto\n    };\n    return (roles[role] || tenuto);\n};\nfunction game() {\n    const controls = [];\n    const state = { player: createPlayer(), ensemble: { [Role.bass]: { volume: 1 },\n            [Role.tenor]: { volume: 1 },\n            [Role.alto]: { volume: 1 },\n            [Role.soprano]: { volume: 1 }\n        }, drones: [],\n        shots: [],\n        drops: createOpeningMusicDrops(), room: { clan: null, role: Role.bass }, level: 0 };\n    const play = (now, role, part) => {\n        var _a;\n        if (part.volume == 1) {\n            if (typeof part.sequencer != 'undefined') {\n                part.sequencer.stop();\n                delete part.sequencer;\n            }\n            return;\n        }\n        const synth = getSynth(role);\n        const beat = Object(_Sequencer__WEBPACK_IMPORTED_MODULE_1__[\"getBeatIndex\"])(now, part.bpm, part.melody);\n        // start the first one\n        if (typeof part.sequencer == 'undefined') {\n            const notes = Object(_Sequencer__WEBPACK_IMPORTED_MODULE_1__[\"intervalsToMelody\"])(part.tonic, getDuration(role), beatmatch(beat, part.melody));\n            const play = synth(now, part.bpm, notes);\n            part.sequencer = play();\n            part.sequencer.osc.onended = () => {\n                delete part.sequencer;\n            };\n            return;\n        }\n        // set up the next loop\n        if ((typeof ((_a = part === null || part === void 0 ? void 0 : part.sequencer) === null || _a === void 0 ? void 0 : _a.osc.onended) == 'undefined') && beat == (part.melody.length - 1)) {\n            const beatWidth = Object(_Sequencer__WEBPACK_IMPORTED_MODULE_1__[\"getBeatLength\"])(part.bpm);\n            const notes = Object(_Sequencer__WEBPACK_IMPORTED_MODULE_1__[\"intervalsToMelody\"])(part.tonic, getDuration(role), part.melody);\n            part.sequencer.osc.onended = () => {\n                delete part.sequencer;\n            };\n        }\n    };\n    const playMusicEnsemble = (now, ensemble) => {\n        Object.entries(ensemble).forEach(([key, part]) => play(now, parseInt(key), part));\n    };\n    const updateSound = (state, ctx) => {\n        const { ensemble } = state;\n        // if ( state.level == 0 ) {\n        //   playMusicEnsemble(ctx.currentTime, Songs.opening)\n        // } else {\n        playMusicEnsemble(ctx.currentTime, state.ensemble);\n        // }\n    };\n    const drawNPCS = (time, state) => {\n        const cAttrs = clanAttributes[state.room.clan];\n        const rAttrs = roleAttributes[state.room.role];\n        // use measuretext here because it depends on the ctx\n        // it is a sidefx that should go in applyMotion instead\n        return (ctx) => {\n            state.drones.forEach((drone, i) => {\n                const { x, y } = drone;\n                const text = rAttrs.text.repeat(2);\n                const metrics = ctx.measureText(text);\n                drone.width = metrics.width;\n                ctx.fillStyle = toColor(cAttrs.rgb, rAttrs.colorMod);\n                ctx.fillText(text, floor(x + droneWidth), floor(y + droneHeight));\n            });\n        };\n    };\n    const drawShots = (time, state) => {\n        return (ctx) => {\n            state.shots.forEach((shot, i) => {\n                ctx.strokeStyle = toColor([(shot.x + shot.y) % 100, shot.x % 255, shot.y % 200]);\n                ctx.arc(shot.x, shot.y, shot.radius, 0, 2 * PI);\n                ctx.lineWidth = (time % 20);\n                ctx.stroke();\n            });\n        };\n    };\n    const drawDrops = (time, state) => {\n        const rgb = [0, 0, 0];\n        return (ctx) => {\n            drawDoors(ctx, state.room.clan);\n            state.drops.forEach(({ x, y, width, height }, i) => {\n                for (let j = 0; j < 3; j++) {\n                    rgb[i] = 255;\n                    const offset = +downScale(time) + (PI * j / 4);\n                    const endpoint = (Math.PI / 4) + offset;\n                    ctx.fillStyle = toColor(rgb);\n                    ctx.arc(x, y, 30, offset, endpoint);\n                    ctx.stroke();\n                    ctx.fill();\n                }\n            });\n        };\n    };\n    const drawPlayer = (time, state) => {\n        const mainColor = 'white';\n        const accent = 'black';\n        const text = '!*!' || false;\n        return (ctx) => {\n            const metrics = ctx.measureText(text);\n            state.player.height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;\n            state.player.width = metrics.width;\n            // Must apply width and height using the ctx\n            ctx.fillStyle = mainColor;\n            ctx.strokeStyle = accent;\n            ctx.strokeText(text, state.player.x, state.player.y);\n            ctx.fillText(text, state.player.x, state.player.y);\n        };\n    };\n    const drawTiles = (time, ctx, state) => {\n        let tw = 30;\n        let th = 30;\n        let nx = canvasWidth / tw;\n        let ny = canvasHeight / th;\n        for (let i = 0; i < nx; i++) {\n            let r = (i * downScale(time, 3)) % 255;\n            // let r = useMod(i,time,state)\n            for (let j = 0; j < ny; j++) {\n                let g = useMod(j, time, state);\n                let b = useMod(i + j, time, state);\n                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;\n                ctx.fillRect(i * tw - i, j * th - j, i * tw + tw, j * tw + tw);\n            }\n        }\n    };\n    const drawTiles2 = (time, ctx) => {\n        let tw = 20;\n        let th = 20;\n        let nx = canvasWidth / tw;\n        let ny = canvasHeight / th;\n        for (let i = 0; i < nx; i++) {\n            let r = (i * downScale(time, 1)) % 255;\n            for (let j = 0; j < ny; j++) {\n                let g = (j * downScale(time, 2)) % 255;\n                let b = (i + j * downScale(time, 4)) % 255;\n                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;\n                ctx.fillRect(i * tw - i, j * th - j, i * tw + tw, j * tw + tw);\n            }\n        }\n    };\n    const drawTiles3 = (time, ctx) => {\n        let tw = 20;\n        let th = 20;\n        let nx = canvasWidth / tw;\n        let ny = canvasHeight / th;\n        for (let i = 0; i < nx; i++) {\n            let r = (i * downScale(time, 1 + time % 5)) % 255;\n            for (let j = 0; j < ny; j++) {\n                let g = (j * downScale(time, time % 2)) % 255;\n                let b = (i + j * downScale(time, time % 4)) % 255;\n                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;\n                ctx.fillRect(i * tw - i, j * th - j, i * tw + tw, j * tw + tw);\n            }\n        }\n    };\n    const drawTiles4 = (time, ctx) => {\n        let tw = time % 200;\n        let th = time % 100;\n        let nx = canvasWidth / tw;\n        let ny = canvasHeight / th;\n        for (let i = 0; i < nx; i++) {\n            let r = (i * downScale(time, 1 + time % 5)) % 255;\n            for (let j = 0; j < ny; j++) {\n                let g = (j * downScale(time, time % 2)) % 255;\n                let b = (i + j * downScale(time, time % 4)) % 255;\n                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;\n                ctx.fillRect(i * tw - i, j * th - j, i * tw + tw, j * tw + tw);\n            }\n        }\n    };\n    const drawDoors = (ctx, clan) => {\n        let altClans = Object.keys(Clan).map(a => parseInt(a)).filter(c => c !== clan).filter(aN);\n        let doorHeight = 40;\n        let offsetWall = 0;\n        let doorWidth = 20;\n        let offsetCeiling = (canvasHeight - doorHeight) / 3;\n        // left door\n        ctx.fillStyle = toColor(clanAttributes[altClans[0]].rgb);\n        ctx.fillRect(offsetWall, offsetCeiling, offsetWall + doorWidth, offsetCeiling + doorHeight);\n        // right door\n        ctx.fillStyle = toColor(clanAttributes[altClans[1]].rgb);\n        ctx.fillRect(canvasWidth - offsetWall - doorWidth, offsetCeiling, canvasWidth - offsetWall + doorWidth, offsetCeiling + doorHeight);\n    };\n    const drawRoom = (time, state) => {\n        // let selection = floor(downScale(time,3))%4\n        // let render = (\n        //   [ drawTiles\n        //   , drawTiles2\n        //   , drawTiles3\n        //   , drawTiles4\n        //   ])[selection]\n        return (ctx) => {\n            drawTiles(time, ctx, state);\n        };\n    };\n    const drawEnsembleOverlay = (time, state) => {\n        return (ctx) => {\n        };\n    };\n    const addControlKey = (key) => {\n        return controls.includes(key) ? controls : controls.concat(key);\n    };\n    const removeControlKey = (key) => controls.filter(k => k !== key);\n    const handleKeydown = (e, time, state) => {\n        if (e.repeat === true) {\n            return;\n        }\n        if (e.key == 'f' && game.controls.includes(e.key)) {\n            game.controls = game.controls.filter(k => k !== e.key);\n        }\n        else {\n            game.controls = game.controls.concat(e.key);\n        }\n        const remove = () => {\n            game.controls = game.controls.filter(k => k !== e.key);\n        };\n        const cleanup = (ev) => {\n            if (e.key === ev.key) {\n                remove();\n                window.removeEventListener('keyup', cleanup);\n            }\n        };\n        window.addEventListener('keyup', cleanup);\n    };\n    const getDrones = (qty = 4, drones = []) => {\n        if (qty === 0)\n            return drones;\n        drones = drones.concat(createDrone());\n        return getDrones(qty - 1, drones);\n    };\n    const drawStage = (time, state, illustrate) => {\n        illustrate((ctx) => ctx.clearRect(0, 0, canvasWidth, canvasHeight));\n        if (state.level == 0) {\n            openingScene(time, state, illustrate);\n            illustrate(drawShots(time, state));\n            return;\n        }\n        if (state.drops.length > 0) {\n            dropScene(time, state, illustrate);\n        }\n        else {\n            swarmScene(time, state, illustrate);\n        }\n    };\n    const swarmScene = (time, state, illustrate) => {\n        illustrate(drawRoom(time, state));\n        illustrate(drawNPCS(time, state));\n        illustrate(drawShots(time, state));\n        illustrate(drawPlayer(time, state));\n    };\n    const dropScene = (time, state, illustrate) => {\n        // illustrate( drawRoom(time, state) )\n        illustrate(drawDrops(time, state));\n        illustrate(drawPlayer(time, state));\n    };\n    const updateListeners = (time, state) => {\n        const listener = (e) => handleKeydown(e, time, state);\n        if (typeof updateListeners.prev == 'function')\n            window.removeEventListener('keydown', updateListeners.prev);\n        window.addEventListener('keydown', updateListeners.prev = listener);\n        return state;\n    };\n    const applyPlayerCollisions = (state, touches, type = '') => {\n        if (type === '')\n            type = touches[0].name;\n        const action = touchHandlers[type];\n        if (typeof action == 'undefined') {\n            // TODO applyPlayerCollisions sould be explicitly called with known arguments\n            return state;\n        }\n        return action(state, touches);\n    };\n    const enumKeys = (e) => Object.keys(e).map(a => parseInt(a)).filter(aN);\n    /** Create a room with new values compared to a previous room. */\n    const nextRoom = (pClan, pRole) => {\n        const altClans = enumKeys(Clan).filter(k => k != pClan);\n        const altRoles = enumKeys(Role).filter(k => k != pRole);\n        const clan = altClans[randomInt(0, altClans.length - 1)];\n        const role = altRoles[randomInt(0, altRoles.length - 1)];\n        return { clan, role };\n    };\n    const setupNextLevel = (state) => {\n        const room = nextRoom(state.room.clan, state.room.role);\n        const drones = getDrones(state.level * 2);\n        return Object.assign(Object.assign({}, state), { drones, room });\n    };\n    const setupDrops = (state) => {\n        // const unit = f({x, y, width: radius, height: radius, clan: Clan[i]})\n        const element = createMusicDrop({ name: 'element',\n            x: canvasWidth / 2,\n            y: canvasHeight / 2,\n            clan: state.room.clan,\n            role: state.room.role\n        });\n        return Object.assign(Object.assign({}, state), { drops: [element] });\n    };\n    const loop = (time, prev, draw, tree) => {\n        tree.clear();\n        let next = applyControls(time, prev);\n        next = applyPositions(time, next);\n        tree = updateTreeIndices(time, next, tree);\n        updateSound(next, _Sequencer__WEBPACK_IMPORTED_MODULE_1__[\"ac\"]);\n        let collisions = handlePlayerCollisions(next, tree);\n        if (collisions.length > 0) {\n            next = applyPlayerCollisions(next, collisions);\n        }\n        if (next.shots.length > 0 && next.drones.length > 0) {\n            // shoot at the drones, remove the hits\n            let drones = next.shots.reduce((drones, shot, i) => {\n                const collisions = tree.retrieve(shot).filter((unit) => collides(unit, shot));\n                return drones.filter(drone => !collisions.includes(drone));\n            }, next.drones);\n            // next = applyShotCollisions(next, tree)\n            next = Object.assign(Object.assign({}, next), { drones });\n        }\n        // you died\n        if (Object.values(next.ensemble).some(part => part.volume == 0)) {\n            location.reload();\n        }\n        if (prev.level != next.level) {\n            next = setupNextLevel(next);\n        }\n        else if (next.drones.length == 0 && next.drops.length == 0) {\n            // The room is clear, provide the drops\n            next = setupDrops(next);\n        }\n        updateListeners(time, next);\n        drawStage(time, next, draw);\n        requestAnimationFrame((ntime) => loop(ntime, next, draw, tree));\n    };\n    const playback = (state, tick, config) => {\n        const { canvasWidth, canvasHeight } = config;\n        const canvas = document.createElement('canvas');\n        canvas.width = canvasWidth;\n        canvas.height = canvasHeight;\n        const ctx = canvas.getContext('2d');\n        ctx.font = '50px monospace';\n        document.body.appendChild(canvas);\n        const scene = (draw) => {\n            ctx.beginPath();\n            ctx.lineWidth = 8;\n            draw(ctx);\n            ctx.closePath();\n        };\n        const tree = new _store__WEBPACK_IMPORTED_MODULE_0__[\"Quadtree\"]({ x: 0, y: 0, width: canvasWidth, height: canvasHeight }, 3, 4);\n        tick(0, state, scene, tree);\n    };\n    const openingScene = (time, state, illustrate) => {\n        const clans = enumKeys(Clan);\n        const containerWidth = canvasWidth * 2 / 3;\n        const offsetWall = canvasWidth / 3;\n        const offsetCeiling = canvasHeight / 3;\n        const elWidth = containerWidth / clans.length;\n        illustrate((ctx) => drawTiles(time, ctx, state));\n        state.drops.forEach((unit, i) => {\n            illustrate((ctx) => {\n                const attrs = clanAttributes[i];\n                const rAttrs = roleAttributes[i];\n                ctx.fillStyle = ctx.strokeStyle = toColor(attrs.rgb, rAttrs[i]);\n                ctx.arc(unit.x, unit.y, unit.radius, 0, 2 * Math.PI);\n                ctx.fill();\n                ctx.stroke();\n            });\n        });\n        illustrate(drawPlayer(time, state));\n    };\n    playback(state, loop, config);\n}\nconst getSoundtrackParts = (clan, role) => {\n    const notes = [];\n    return notes;\n};\n/**\nthe game state must be aware of current global baseline bpm and measure number\nit does not need a record of it\n\n\n*/\n// todo decide if it is worth having a global async controls or use something else\ngame.controls = [];\ngame();\n\n\n//# sourceURL=webpack:///./src/index.ts?");

/***/ }),

/***/ "./src/music.ts":
/*!**********************!*\
  !*** ./src/music.ts ***!
  \**********************/
/*! exports provided: transpose, createParts, createGenericProgression, play, setup */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transpose\", function() { return transpose; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createParts\", function() { return createParts; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createGenericProgression\", function() { return createGenericProgression; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"play\", function() { return play; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setup\", function() { return setup; });\n/* harmony import */ var _pitch_frequencies__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pitch-frequencies */ \"./src/pitch-frequencies.ts\");\n\nvar PitchClass;\n(function (PitchClass) {\n    PitchClass[PitchClass[\"C\"] = 0] = \"C\";\n    PitchClass[PitchClass[\"Cs\"] = 1] = \"Cs\";\n    PitchClass[PitchClass[\"D\"] = 2] = \"D\";\n    PitchClass[PitchClass[\"Ds\"] = 3] = \"Ds\";\n    PitchClass[PitchClass[\"E\"] = 4] = \"E\";\n    PitchClass[PitchClass[\"F\"] = 5] = \"F\";\n    PitchClass[PitchClass[\"Fs\"] = 6] = \"Fs\";\n    PitchClass[PitchClass[\"G\"] = 7] = \"G\";\n    PitchClass[PitchClass[\"Gs\"] = 8] = \"Gs\";\n    PitchClass[PitchClass[\"A\"] = 9] = \"A\";\n    PitchClass[PitchClass[\"As\"] = 10] = \"As\";\n    PitchClass[PitchClass[\"B\"] = 11] = \"B\";\n})(PitchClass || (PitchClass = {}));\nvar Intervals;\n(function (Intervals) {\n    Intervals[Intervals[\"Unison\"] = 0] = \"Unison\";\n    Intervals[Intervals[\"MinorSecond\"] = 1] = \"MinorSecond\";\n    Intervals[Intervals[\"MajorSecond\"] = 2] = \"MajorSecond\";\n    Intervals[Intervals[\"MinorThird\"] = 3] = \"MinorThird\";\n    Intervals[Intervals[\"MajorThird\"] = 4] = \"MajorThird\";\n    Intervals[Intervals[\"PerfectFourth\"] = 5] = \"PerfectFourth\";\n    Intervals[Intervals[\"Tritone\"] = 6] = \"Tritone\";\n    Intervals[Intervals[\"PerfectFifth\"] = 7] = \"PerfectFifth\";\n    Intervals[Intervals[\"MinorSixth\"] = 8] = \"MinorSixth\";\n    Intervals[Intervals[\"MajorSixth\"] = 9] = \"MajorSixth\";\n    Intervals[Intervals[\"MinorSeventh\"] = 10] = \"MinorSeventh\";\n    Intervals[Intervals[\"MajorSeventh\"] = 11] = \"MajorSeventh\";\n})(Intervals || (Intervals = {}));\nvar Relationships;\n(function (Relationships) {\n    Relationships[Relationships[\"Tonic\"] = 0] = \"Tonic\";\n    Relationships[Relationships[\"Supertonic\"] = 1] = \"Supertonic\";\n    Relationships[Relationships[\"Mediant\"] = 2] = \"Mediant\";\n    Relationships[Relationships[\"Subdominant\"] = 3] = \"Subdominant\";\n    Relationships[Relationships[\"Dominant\"] = 4] = \"Dominant\";\n    Relationships[Relationships[\"Submediant\"] = 5] = \"Submediant\";\n    Relationships[Relationships[\"Leading\"] = 6] = \"Leading\";\n})(Relationships || (Relationships = {}));\nvar Waves;\n(function (Waves) {\n    Waves[Waves[\"sine\"] = 0] = \"sine\";\n    Waves[Waves[\"square\"] = 1] = \"square\";\n    Waves[Waves[\"sawtooth\"] = 2] = \"sawtooth\";\n    Waves[Waves[\"triangle\"] = 3] = \"triangle\";\n})(Waves || (Waves = {}));\nlet translatePitch = (pitch) => {\n    switch (pitch) {\n        case `Cs`:\n        case `C#`:\n        case `C sharp`:\n        case `C Sharp`:\n            return PitchClass.Cs;\n        case `D`:\n            return PitchClass.D;\n        case `Ds`:\n        case `D#`:\n        case `D sharp`:\n        case `D Sharp`:\n            return PitchClass.Ds;\n        case `E`:\n            return PitchClass.E;\n        case `F`:\n            return PitchClass.F;\n        case `Fs`:\n        case `F#`:\n        case `F sharp`:\n        case `F Sharp`:\n            return PitchClass.Fs;\n        case `G`:\n            return PitchClass.G;\n        case `Gs`:\n        case `G#`:\n        case `G sharp`:\n        case `G Sharp`:\n            return PitchClass.Gs;\n        case `A`:\n            return PitchClass.A;\n        case `As`:\n        case `A#`:\n        case `A sharp`:\n        case `A Sharp`:\n            return PitchClass.As;\n        case `B`:\n            return PitchClass.B;\n    }\n};\nlet print = (...any) => console.log(any);\nlet next = (limit = 1, list = [], mod, n = 0) => {\n    if (list.length == limit)\n        return list;\n    let prev = list[list.length - 1];\n    let newx = mod(n, prev, list[0]);\n    return next(limit, list.concat(newx), mod, n + 1);\n};\nlet transpose = (freq, steps) => {\n    // Use `NaN` to represent a rest\n    // if ( isNaN(freq)) \n    //   return 0\n    let modTable = transpositionMap();\n    let bound = modTable.length - 1;\n    if (steps <= bound) {\n        return freq * modTable[steps];\n    }\n    steps = steps - bound;\n    return transpose(transpose(freq, bound), steps);\n};\nlet chordByFreq = (freq) => (quality = 'major') => qualities()[quality](freq);\nlet octaveSeries = (startFreq = 32, qty = 10) => next(qty, [startFreq], (n, prev, first) => prev * 2);\nlet getHarmonicSeries = (startFreq = 32, qty = 10) => next(qty, [], (n, prev, first) => (n == 0 ? startFreq : (prev * (1 + n)) / n));\nlet selectHarmonicPoints = (frequencies, n = 0) => frequencies.reduce((selections, freq, index) => {\n    let amtToSkip = selections.length;\n    if (n == amtToSkip) {\n        n = 0;\n        return selections.concat(freq);\n    }\n    n++;\n    return selections;\n}, []);\nlet pitchclassToNote = (p) => {\n    if (typeof p == 'string')\n        return p;\n    let note = PitchClass[p];\n    // while (note > PitchClass.length)\n    //   note = note - PitchClass.length\n    return note;\n};\nlet pitchOctave = (pitch, octave = 5) => `${pitch}${octave.toString()}`;\nlet nameToFreq = (pitchclass) => (_pitch_frequencies__WEBPACK_IMPORTED_MODULE_0__[\"frequencies\"][pitchOctave(pitchclass)] || 0);\n// adapted from wikipedia (Interval, music theory)\n// risig is the type of tritone to select. true for rising, false for falling \nlet transpositionMap = (rising = true) => [1, (16 / 15), (9 / 8), (6 / 5), (5 / 4), (4 / 3), rising ? (45 / 32) : (25 / 18)];\nlet createMajorChord = (freq) => [freq,\n    transpose(freq, 4),\n    transpose(freq, 7)];\nlet createMinorChord = (freq) => [freq,\n    transpose(freq, 3),\n    transpose(freq, 7)];\nlet createAugmentedChord = (freq) => [freq,\n    transpose(freq, 4),\n    transpose(freq, 8)];\nlet createDiminishedChord = (freq) => [freq,\n    transpose(freq, 3),\n    transpose(freq, 6)];\nlet createDominantChord = (freq) => [freq,\n    transpose(freq, 4),\n    transpose(freq, 10)];\nlet harmonicProgression = (fundamental = 32) => {\n    let fundamentals = getHarmonicSeries(fundamental);\n    return fundamentals;\n};\nlet selectHarmonicRelatives = (tonic, relatives) => {\n    let r = { supertonic: Intervals.MajorSecond,\n        mediant: Intervals.MajorThird,\n        subdominant: Intervals.PerfectFourth,\n        dominant: Intervals.PerfectFifth,\n        submediant: Intervals.MajorSixth,\n        leading: Intervals.MajorSeventh };\n    let keys = Object.keys(r);\n    return relatives.reduce((selections, relative) => (keys.includes(relative) ? Object.assign(Object.assign({}, selections), { [relative]: (tonic + r[relative]) }) : selections), { tonic });\n};\nlet qualities = () => ({ major: createMajorChord,\n    minor: createMinorChord,\n    augmented: createAugmentedChord,\n    diminished: createDiminishedChord,\n    dominant: createDominantChord });\nlet getMode = (state) => {\n    let { major, minor, augmented, diminished, dominant } = qualities();\n    switch (state) {\n        case 'major':\n        default:\n            return ({ tonic: major,\n                supertonic: minor,\n                mediant: minor,\n                subdominant: major,\n                dominant: dominant,\n                submediant: minor,\n                leading: diminished });\n    }\n};\nlet createParts = (root, relationships = ['subdominant', 'dominant'], mode = 'major') => {\n    let chordMap = getMode(mode);\n    let relatives = selectHarmonicRelatives(PitchClass[root], relationships);\n    let parts = {};\n    // @ts-ignore\n    Object.entries(relatives).forEach(([role, pitchclass]) => {\n        parts[role] =\n            { name: role,\n                note: pitchclassToNote(pitchclass),\n                pitchclass: relatives[role],\n                freq: transpose(nameToFreq(root), relatives[role]),\n                constructor: chordMap[role],\n                get: function chord(octave = 1) { return this.constructor(parts[role].freq / 4 * (octave / 1)); }\n            };\n    });\n    return parts;\n};\nlet createGenericProgression = (root = `C`) => {\n    let parts = createParts(root);\n    let fill = (chord) => Array(4).fill(chord);\n    let tonic = parts.tonic.get(1);\n    let subdominant = parts.subdominant.get(1);\n    let dominant = parts.dominant.get(1);\n    return ([fill(tonic),\n        fill(subdominant),\n        fill(dominant),\n        [subdominant, dominant, subdominant, dominant]]);\n};\nlet osc = (ctx, opts = {}) => {\n    let oscillator = ctx.createOscillator();\n    let gain = ctx.createGain();\n    gain.connect(ctx.destination);\n    oscillator.connect(gain);\n    oscillator.type = 'square';\n    gain.volume = 0.1;\n    oscillator.gain = gain;\n    for (let o in opts)\n        oscillator[o] = opts[o];\n    return oscillator;\n};\nlet enqueue = (osc, freq, time) => osc.frequency.setValueAtTime(freq, time);\n// let createTrigger = (osc, freq: Freq) =>\n//   (trigger, f?: Freq) =>\n//     osc.frequency.setValueAtTime(f || freq, trigger());  \nlet ar = (osc, freq, start, duration) => {\n    // osc.gain.volume = 0.8\n    osc.frequency.value = freq;\n    // setTimeout(osc.gain.volume=0),duration)\n};\nlet playbackSequence = (list, fn, loop = false) => {\n    let chain = list.reduce(fn, Promise.resolve());\n    return (loop)\n        ? chain.then(() => playbackSequence(list, fn, loop))\n        : chain;\n};\nlet createTime = (bpm, opts = {}, n = 4, d = 4, _ = 0) => {\n    let beat = 60 / (bpm);\n    let bar = n * beat;\n    let ratio = (a = n, b = d) => a / b;\n    const time = { bpm,\n        beat,\n        bar,\n        ratio,\n        moment: _,\n        numerator: n,\n        denominator: d\n    };\n    return Object.assign(Object.assign({}, time), opts);\n};\nlet playBar = (bar, voices, time) => new Promise((resolve, reject) => {\n    let phraseNum = 0;\n    let sustain = 0.75;\n    function schedule(notes, beat) {\n        const beatStart = beat * time.beat;\n        let timestamp = time.moment + beatStart;\n        notes.forEach((freq, voice) => {\n            let osc = voices[voice];\n            osc.frequency.setValueAtTime(freq, timestamp);\n        });\n        if (beat == (time.numerator - 1)) {\n            phraseNum++;\n        }\n    }\n    bar.forEach((noteStack, beat) => schedule(noteStack, beat));\n    setTimeout(resolve, time.bar);\n});\nlet play = ({ ctx, start }) => {\n    let time = createTime({ bpm: 132,\n        numerator: 4,\n        denominator: 4,\n        start: Date.now() - start });\n    let chords = createGenericProgression(`F`);\n    let voices = chords.reduce((voices, bar, i) => [...voices, osc(ctx, { type: Waves[i] })], []);\n    let chainPlayback = (chain, bar, index, list) => {\n        return chain.then(() => new Promise((resolve, reject) => {\n            let now = new Date();\n            //@ts-ignore\n            time.moment = now - start;\n            playBar(bar, voices, time)\n                .then(resolve);\n        }));\n    };\n    playbackSequence(chords, chainPlayback, true);\n    voices.forEach(osc => osc.start());\n};\nlet setup = () => {\n    // @ts-ignore\n    let ctx = new (window.AudioContext || window.webkitAudioContext)();\n    let start = Date.now();\n    return (event) => play({ ctx, start });\n};\n\n\n//# sourceURL=webpack:///./src/music.ts?");

/***/ }),

/***/ "./src/pitch-frequencies.ts":
/*!**********************************!*\
  !*** ./src/pitch-frequencies.ts ***!
  \**********************************/
/*! exports provided: frequencies */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"frequencies\", function() { return frequencies; });\nconst frequencies = { C0: 16.2,\n    Db0: 17.17,\n    D0: 18.19,\n    Eb0: 19.27,\n    E0: 20.41,\n    F0: 21.63,\n    Gb0: 22.91,\n    G0: 24.28,\n    Ab0: 25.72,\n    A0: 27.25,\n    Bb0: 28.87,\n    B0: 30.59,\n    C1: 32.41,\n    Db1: 34.33,\n    D1: 36.37,\n    Eb1: 38.54,\n    E1: 40.83,\n    F1: 43.26,\n    Gb1: 45.83,\n    G1: 48.55,\n    Ab1: 51.44,\n    A1: 54.5,\n    Bb1: 57.74,\n    B1: 61.17,\n    C2: 64.81,\n    Db2: 68.67,\n    D2: 72.75,\n    Eb2: 77.07,\n    E2: 81.66,\n    F2: 86.51,\n    Gb2: 91.66,\n    G2: 97.11,\n    Ab2: 102.88,\n    A2: 109,\n    Bb2: 115.48,\n    B2: 122.35,\n    C3: 129.62,\n    Db3: 137.33,\n    D3: 145.5,\n    Eb3: 154.15,\n    E3: 163.32,\n    F3: 173.03,\n    Gb3: 183.32,\n    G3: 194.22,\n    Ab3: 205.76,\n    A3: 218,\n    Bb3: 230.96,\n    B3: 244.7,\n    C4: 259.25,\n    Db4: 274.66,\n    D4: 290.99,\n    Eb4: 308.3,\n    E4: 326.63,\n    F4: 346.05,\n    Gb4: 366.63,\n    G4: 388.43,\n    Ab4: 411.53,\n    A4: 436,\n    Bb4: 461.93,\n    B4: 489.39,\n    C5: 518.49,\n    Db5: 549.33,\n    D5: 581.99,\n    Eb5: 616.6,\n    E5: 653.26,\n    F5: 692.11,\n    Gb5: 733.26,\n    G5: 776.86,\n    Ab5: 823.06,\n    A5: 872,\n    Bb5: 923.85,\n    B5: 978.79,\n    C6: 1036.99,\n    Db6: 1098.65,\n    D6: 1163.98,\n    Eb6: 1233.19,\n    E6: 1306.52,\n    F6: 1384.21,\n    Gb6: 1466.52,\n    G6: 1553.73,\n    Ab6: 1646.12,\n    A6: 1744,\n    Bb6: 1847.7,\n    B6: 1957.57,\n    C7: 2073.98,\n    Db7: 2197.3,\n    D7: 2327.96,\n    Eb7: 2466.39,\n    E7: 2613.05,\n    F7: 2768.43,\n    Gb7: 2933.05,\n    G7: 3107.45,\n    Ab7: 3292.23,\n    A7: 3488,\n    Bb7: 3695.41,\n    B7: 3915.15,\n    C8: 4147.95,\n    Db8: 4394.6,\n    D8: 4655.92,\n    Eb8: 4932.78,\n    E8: 5226.09,\n    F8: 5536.85,\n    Gb8: 5866.09,\n    G8: 6214.91,\n    Ab8: 6584.47,\n    A8: 6976,\n    Bb8: 7390.81,\n    B8: 7830.3 };\n\n\n//# sourceURL=webpack:///./src/pitch-frequencies.ts?");

/***/ }),

/***/ "./src/store.ts":
/*!**********************!*\
  !*** ./src/store.ts ***!
  \**********************/
/*! exports provided: Quadtree */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Quadtree\", function() { return Quadtree; });\nfunction Quadtree(bounds, max_objects = 4, max_levels = 10, level = 0) {\n    this.max_objects = max_objects || 10;\n    this.max_levels = max_levels || 4;\n    this.level = level || 0;\n    this.bounds = bounds;\n    this.objects = [];\n    this.nodes = [];\n}\n;\n/**\n * Split the node into 4 subnodes\n */\nQuadtree.prototype.split = function () {\n    var nextLevel = this.level + 1, subWidth = this.bounds.width / 2, subHeight = this.bounds.height / 2, x = this.bounds.x, y = this.bounds.y;\n    //top right node\n    this.nodes[0] = new Quadtree({\n        x: x + subWidth,\n        y: y,\n        width: subWidth,\n        height: subHeight\n    }, this.max_objects, this.max_levels, nextLevel);\n    //top left node\n    this.nodes[1] = new Quadtree({\n        x: x,\n        y: y,\n        width: subWidth,\n        height: subHeight\n    }, this.max_objects, this.max_levels, nextLevel);\n    //bottom left node\n    this.nodes[2] = new Quadtree({\n        x: x,\n        y: y + subHeight,\n        width: subWidth,\n        height: subHeight\n    }, this.max_objects, this.max_levels, nextLevel);\n    //bottom right node\n    this.nodes[3] = new Quadtree({\n        x: x + subWidth,\n        y: y + subHeight,\n        width: subWidth,\n        height: subHeight\n    }, this.max_objects, this.max_levels, nextLevel);\n};\n/**\n * Determine which node the object belongs to\n * @param Object pRect      bounds of the area to be checked, with x, y, width, height\n * @return Array            an array of indexes of the intersecting subnodes\n *                          (0-3 = top-right, top-left, bottom-left, bottom-right / ne, nw, sw, se)\n */\nQuadtree.prototype.getIndex = function (pRect) {\n    var indexes = [], verticalMidpoint = this.bounds.x + (this.bounds.width / 2), horizontalMidpoint = this.bounds.y + (this.bounds.height / 2);\n    var startIsNorth = pRect.y < horizontalMidpoint, startIsWest = pRect.x < verticalMidpoint, endIsEast = pRect.x + pRect.width > verticalMidpoint, endIsSouth = pRect.y + pRect.height > horizontalMidpoint;\n    //top-right quad\n    if (startIsNorth && endIsEast) {\n        indexes.push(0);\n    }\n    //top-left quad\n    if (startIsWest && startIsNorth) {\n        indexes.push(1);\n    }\n    //bottom-left quad\n    if (startIsWest && endIsSouth) {\n        indexes.push(2);\n    }\n    //bottom-right quad\n    if (endIsEast && endIsSouth) {\n        indexes.push(3);\n    }\n    return indexes;\n};\n/**\n * Insert the object into the node. If the node\n * exceeds the capacity, it will split and add all\n * objects to their corresponding subnodes.\n * @param Object pRect        bounds of the object to be added { x, y, width, height }\n */\nQuadtree.prototype.insert = function (pRect) {\n    var i = 0, indexes;\n    //if we have subnodes, call insert on matching subnodes\n    if (this.nodes.length) {\n        indexes = this.getIndex(pRect);\n        for (i = 0; i < indexes.length; i++) {\n            this.nodes[indexes[i]].insert(pRect);\n        }\n        return pRect;\n    }\n    //otherwise, store object here\n    this.objects.push(pRect);\n    //max_objects reached\n    if (this.objects.length > this.max_objects && this.level < this.max_levels) {\n        //split if we don't already have subnodes\n        if (!this.nodes.length) {\n            this.split();\n        }\n        //add all objects to their corresponding subnode\n        for (i = 0; i < this.objects.length; i++) {\n            indexes = this.getIndex(this.objects[i]);\n            for (var k = 0; k < indexes.length; k++) {\n                this.nodes[indexes[k]].insert(this.objects[i]);\n            }\n        }\n        //clean up this node\n        this.objects = [];\n    }\n    return pRect;\n};\n/**\n * Return all objects that could collide with the given object\n * @param Object pRect      bounds of the object to be checked { x, y, width, height }\n * @Return Array            array with all detected objects\n */\nQuadtree.prototype.retrieve = function (pRect) {\n    var indexes = this.getIndex(pRect), returnObjects = this.objects;\n    //if we have subnofdes, retrieve their objects\n    if (this.nodes.length) {\n        for (var i = 0; i < indexes.length; i++) {\n            returnObjects = returnObjects.concat(this.nodes[indexes[i]].retrieve(pRect));\n        }\n    }\n    //remove duplicates\n    returnObjects = returnObjects.filter(function (item, index) {\n        return returnObjects.indexOf(item) >= index;\n    });\n    return returnObjects;\n};\n/**\n * Clear the quadtree\n */\nQuadtree.prototype.clear = function () {\n    this.objects = [];\n    for (let i = 0; i < this.nodes.length; i++) {\n        if (this.nodes.length) {\n            this.nodes[i].clear();\n        }\n    }\n    this.nodes = [];\n};\n\n\n//# sourceURL=webpack:///./src/store.ts?");

/***/ })

/******/ });