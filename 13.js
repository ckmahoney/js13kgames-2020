/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/Sequencer.ts":
/*!**************************!*\
  !*** ./src/Sequencer.ts ***!
  \**************************/
/*! exports provided: transpose, ac, Sequence, intervalsToMelody, partLead, partHarmony, partBass, getBeatIndex, getBeatLength, getStartOfNextBar */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transpose\", function() { return transpose; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ac\", function() { return ac; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Sequence\", function() { return Sequence; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"intervalsToMelody\", function() { return intervalsToMelody; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"partLead\", function() { return partLead; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"partHarmony\", function() { return partHarmony; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"partBass\", function() { return partBass; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getBeatIndex\", function() { return getBeatIndex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getBeatLength\", function() { return getBeatLength; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getStartOfNextBar\", function() { return getStartOfNextBar; });\nlet transpositionMap = (rising = true) => [1, (16 / 15), (9 / 8), (6 / 5), (5 / 4), (4 / 3), rising ? (45 / 32) : (25 / 18)];\nlet transpose = (freq, steps) => {\n    // Use `NaN` to represent a rest\n    // if ( isNaN(freq)) \n    //   return 0\n    let modTable = transpositionMap();\n    let bound = modTable.length - 1;\n    if (steps <= bound) {\n        return freq * modTable[steps];\n    }\n    steps = steps - bound;\n    return transpose(transpose(freq, bound), steps);\n};\nconst ac = new AudioContext();\nconst delay = ac.createDelay(4);\ndelay.delayTime.value = (60 / 120 / 4); //quarter note at 120bpm\ndelay.connect(ac.destination);\nfunction Note(freq, duration) {\n    return [freq, duration];\n}\nfunction Sequence(tempo, notes = []) {\n    this.ac = ac;\n    this.createFxNodes();\n    this.tempo = tempo || 120;\n    this.loop = true;\n    this.smoothing = 0;\n    this.staccato = 0;\n    this.notes = notes;\n}\n// create gain and EQ nodes, then connect 'em\nSequence.prototype.createFxNodes = function () {\n    const eq = [['bass', 100], ['mid', 1000], ['treble', 2500]];\n    let prev = this.gain = this.ac.createGain();\n    eq.forEach(function (config, fx) {\n        fx = this[config[0]] = this.ac.createBiquadFilter();\n        fx.type = 'peaking';\n        fx.frequency.value = config[1];\n        prev.connect(prev = fx);\n    }.bind(this));\n    this.lp = this.ac.createBiquadFilter();\n    this.lp.type = 'lowpass';\n    this.lp.frequency.value = 15000;\n    prev.connect(prev = this.lp);\n    this.hp = this.ac.createBiquadFilter();\n    this.hp.type = 'highpass';\n    this.hp.frequency.value = 80;\n    prev.connect(prev = this.hp);\n    prev.connect(this.ac.destination);\n    return this;\n};\n// recreate the oscillator node (happens on every play)\nSequence.prototype.createOscillator = function () {\n    this.stop();\n    this.osc = this.ac.createOscillator();\n    this.osc.type = this.waveType || 'square';\n    this.gain.value = 0.1;\n    if (this.type == 'lead') {\n        this.osc.connect(delay);\n        this.osc.connect(this.ac.destination);\n        this.osc.connect(this.ac.destination);\n    }\n    this.osc.connect(this.gain);\n    return this;\n};\n// schedules this.notes[ index ] to play at the given time\n// returns an AudioContext timestamp of when the note will *end*\nSequence.prototype.scheduleNote = function (index, when) {\n    const duration = 60 / this.tempo * this.notes[index][1], cutoff = duration * (1 - (this.staccato || 0));\n    this.setFrequency(this.notes[index][0], when);\n    if (this.smoothing && this.notes[index][0]) {\n        this.slide(index, when, cutoff);\n    }\n    this.setFrequency(0, when + cutoff);\n    return when + duration;\n};\n// get the next note\nSequence.prototype.getNextNote = function (index) {\n    return this.notes[index < this.notes.length - 1 ? index + 1 : 0];\n};\n// how long do we wait before beginning the slide? (in seconds)\nSequence.prototype.getSlideStartDelay = function (duration) {\n    return duration - Math.min(duration, 60 / this.tempo * this.smoothing);\n};\n// slide the note at <index> into the next note at the given time,\n// and apply staccato effect if needed\nSequence.prototype.slide = function (index, when, cutoff) {\n    const next = this.getNextNote(index), start = this.getSlideStartDelay(cutoff);\n    this.setFrequency(this.notes[index][0], when + start);\n    this.rampFrequency(next[0], when + cutoff);\n    return this;\n};\nSequence.prototype.setFrequency = function (freq, when) {\n    this.osc.frequency.setValueAtTime(freq, when);\n    return this;\n};\nSequence.prototype.rampFrequency = function (freq, when) {\n    this.osc.frequency.linearRampToValueAtTime(freq, when);\n    return this;\n};\n// run through all notes in the sequence and schedule them\nSequence.prototype.play = function (when) {\n    when = typeof when === 'number' ? when : this.ac.currentTime;\n    this.createOscillator();\n    this.osc.start(when + 1);\n    this.notes.forEach(function (note, i) {\n        when = this.scheduleNote(i, when);\n    }.bind(this));\n    this.osc.stop(when);\n    return this;\n};\n// stop playback, null out the oscillator, cancel parameter automation\nSequence.prototype.stop = function () {\n    if (this.osc) {\n        this.osc.stop(0);\n        this.osc.frequency.cancelScheduledValues(0);\n        this.osc = null;\n    }\n    return this;\n};\nconst intervalsToMelody = (root, duration = (i) => 1, intervals = []) => intervals.map((interval, i) => ([isNaN(interval) ? 0 : transpose(root, interval), duration(i)]));\nconst partLead = (when, tempo, melody) => {\n    const seq = new Sequence(tempo, melody);\n    seq.staccato = 0.55;\n    seq.gain.gain.value = 1.0;\n    seq.bass.frequency.value = 400;\n    seq.bass.gain.value = -4;\n    seq.mid.frequency.value = 800;\n    seq.mid.gain.value = 3;\n    seq.waveType = 'square';\n    seq.hp.frequency.value = 1200;\n    seq.role = 'lead';\n    return function play() {\n        seq.play(when);\n        return seq;\n    };\n};\nconst partHarmony = (when, tempo, melody) => {\n    const seq = new Sequence(tempo, melody);\n    seq.mid.frequency.value = 1200;\n    seq.gain.gain.value = 0.8;\n    seq.staccato = 0.55;\n    seq.waveType = 'triangle';\n    return function play() {\n        seq.play(when);\n        return seq;\n    };\n};\nconst partBass = (when, tempo, melody) => {\n    const seq = new Sequence(tempo, melody);\n    seq.staccato = 0.05;\n    seq.smoothing = 0.05;\n    seq.gain.gain.value = 0.65;\n    seq.mid.gain.value = 3;\n    seq.bass.gain.value = 6;\n    seq.bass.frequency.value = 80;\n    seq.mid.gain.value = -2;\n    seq.mid.frequency.value = 500;\n    seq.treble.gain.value = -4;\n    seq.treble.frequency.value = 1400;\n    seq.waveType = 'square';\n    return function play() {\n        seq.play(when);\n        return seq;\n    };\n};\nfunction getBeatIndex(time, bpm, notes = []) {\n    const beatDuration = getBeatLength(bpm);\n    const barDuration = beatDuration * notes.length;\n    const location = time % barDuration;\n    return notes.findIndex((note, i) => location <= ((i + 1) * beatDuration));\n}\nfunction getBeatLength(bpm) {\n    return (60 / bpm);\n}\nfunction getStartOfNextBar(time, bpm, notes) {\n    let currentIndex = getBeatIndex(time, bpm, notes);\n    const beatWidth = getBeatLength(bpm);\n}\n\n\n//# sourceURL=webpack:///./src/Sequencer.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./store */ \"./src/store.ts\");\n/* harmony import */ var _Sequencer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Sequencer */ \"./src/Sequencer.ts\");\n\n\nconst { abs, sin, cos, pow, sqrt, floor, ceil, random, PI, max, min } = Math;\nvar Role;\n(function (Role) {\n    Role[Role[\"bass\"] = 0] = \"bass\";\n    Role[Role[\"tenor\"] = 1] = \"tenor\";\n    Role[Role[\"alto\"] = 2] = \"alto\";\n    Role[Role[\"soprano\"] = 3] = \"soprano\";\n})(Role || (Role = {}));\nvar Clan;\n(function (Clan) {\n    Clan[Clan[\"Blue\"] = 0] = \"Blue\";\n    Clan[Clan[\"Red\"] = 1] = \"Red\";\n    Clan[Clan[\"Yellow\"] = 2] = \"Yellow\";\n})(Clan || (Clan = {}));\n// # Game Data \nconst clanAttributes = { [Clan.Red]: { rgb: [255, 0, 0]\n    },\n    [Clan.Blue]: { rgb: [0, 0, 255]\n    },\n    [Clan.Yellow]: { rgb: [0, 255, 0]\n    }\n};\nconst roleAttributes = { [Role.bass]: { colorMod(n, time) { return n == 255 ? 50 : n; },\n        text: '#'\n    },\n    [Role.tenor]: { colorMod(n, time) { return n == 255 ? 100 : n; },\n        text: '\\\\-'\n    },\n    [Role.alto]: { colorMod(n, time) { return n == 255 ? 175 : n; },\n        text: '=/'\n    },\n    [Role.soprano]: { colorMod(n, time) { return 255; },\n        text: '@' }\n};\nconst Presets = { [Clan.Yellow]: { tonic: 88,\n        bpm: 70,\n        voices: { [Role.bass]: [0, 5, 0, 7],\n            [Role.tenor]: [0, 5, NaN, 5],\n            [Role.alto]: [7, 2, NaN],\n            [Role.soprano]: [12, 4, NaN, 12, 7, NaN, 4, 7]\n        }\n    },\n    [Clan.Red]: { tonic: 52,\n        bpm: 93.333,\n        voices: { [Role.bass]: [7, 0],\n            [Role.tenor]: [4, 4, 2, 4],\n            [Role.alto]: [7, 4, 7, NaN],\n            [Role.soprano]: [12, NaN, NaN, 0]\n        }\n    },\n    [Clan.Blue]: { tonic: 128,\n        bpm: 124.44 / 2,\n        voices: { [Role.bass]: [12, 0, NaN, 0],\n            [Role.tenor]: [0, 4, 0],\n            [Role.alto]: [7, NaN, 12],\n            [Role.soprano]: [4, NaN, NaN, 12, 7, 4, 7, NaN]\n        }\n    }\n};\nconst Songs = { \"opening\": { tonic: 84,\n        bpm: 132,\n        voices: { [Role.bass]: [0, NaN, 0, 3, 0, NaN, 0, 4, 0, NaN, 0, 7, 9, 5, 7, 2],\n            [Role.tenor]: [3, 3, 3, 3, 4, 4, 4, 4, 7, 7, 7, 7, 10, 10, 10, 10],\n            [Role.alto]: [NaN, 5, NaN, 5, NaN, 7, NaN, 7, NaN, 2, NaN, 2, NaN, 5, NaN, 5],\n            [Role.soprano]: [10, NaN, NaN, NaN, 11, NaN, NaN, NaN, NaN, 11, NaN, NaN, NaN, NaN, 10, NaN, NaN, NaN, NaN,]\n        }\n    }\n};\nconst mods = [(t, state) => floor(downScale(t, (state.level * 2) + 5) % 255),\n    (t, state) => floor(downScale(t, 51 + state.level) % 255),\n    (t, state) => floor(downScale(t, 91 - state.level) % 255),\n    (t, state) => floor(t + 223 % 20)];\nconst useMod = (n, time, state) => mods[n % mods.length](time, state);\nconst collides = (unit, obj) => {\n    if (unit.objectID == obj.objectID)\n        return false;\n    return !(unit.x > obj.x + obj.width ||\n        unit.x + obj.width < obj.x ||\n        unit.y > obj.y + obj.height ||\n        unit.y + obj.height < obj.y);\n};\nconst applyDroneDamage = (role, ensemble) => {\n    const next = Object.assign({}, ensemble);\n    const mirrors = [[Role.bass, Role.soprano],\n        [Role.tenor, Role.alto]];\n    let dmg = 0;\n    for (let duo of mirrors) {\n        if (duo.includes(role)) {\n            dmg = (duo[0] == role)\n                ? 1\n                : 2;\n            next[role].volume = next[role].volume - dmg;\n        }\n    }\n    return next;\n};\nconst touchHandlers = { drone(state, touches) {\n        const ensemble = touches.reduce((ensemble, drone) => applyDroneDamage(state.room.role, state.ensemble), touches);\n        const defenderIDs = touches.map(drone => drone.objectID);\n        // destroy on contact\n        const drones = state.drones.filter(drone => !defenderIDs.includes(drone.objectID));\n        return Object.assign(Object.assign({}, state), { drones, ensemble });\n    },\n    element(state, touches) {\n        if (state.level == 0 && touches.length > 1) {\n            // prevent multiple collisions when there are 3 nodes\n            return state;\n        }\n        const element = touches[0];\n        const room = { clan: element.clan,\n            role: (state.level == 0) ? Role.bass : element.role };\n        const ensemble = addToEnsemble(state.ensemble, room.clan, room.role);\n        return (Object.assign(Object.assign({}, state), { ensemble,\n            room, drops: [], level: state.level + 1 }));\n    }\n};\nconst canvasWidth = window.innerWidth;\nconst canvasHeight = window.innerHeight;\nconst playerHeight = 80;\nconst playerWidth = 80;\nconst droneWidth = 50;\nconst droneHeight = 50;\nconst elementRadius = min(100, canvasWidth / 6);\nconst config = {\n    canvasWidth,\n    canvasHeight\n};\nconst objectID = () => {\n    return objectID.prev++;\n};\nobjectID.prev = 0;\nconst downScale = (n, scale = 3) => n * pow(10, -(scale));\nconst throttle = (seconds = 2) => setTimeout(() => { debugger; }, seconds * 1000);\nconst aN = n => (!isNaN(n) && typeof n == 'number');\nconst toColor = (rgb, mod = (n, time) => n) => {\n    if (rgb.length != 3) {\n        return '';\n    }\n    const [r, g, b] = rgb.map(mod).map(n => n.toString());\n    return `rgb(${r},${g},${b})`;\n};\nconst randomInt = (min = 0, max = 1) => floor(random() * (floor(max) - ceil(min) + 1)) + ceil(min);\nconst log = (...any) => console.log(any);\nconst coinToss = () => (Math.random() < 0.5);\nconst isNearWall = (u, threshold = 0.1) => (u.x <= canvasWidth * threshold) && (u.y <= canvasHeight * threshold);\nconst walk = (u, step = 1) => {\n    let direction = u.lastwalk ? 'x' : 'y';\n    return (Object.assign(Object.assign({}, u), { lastwalk: !u.lastwalk, [direction]: coinToss() ? u[direction] + 1 : u[direction] - 1 }));\n};\nconst moveLeft = (u, amt = 7) => (Object.assign(Object.assign({}, u), { x: u.x > 0 ? u.x -= amt : 0 }));\nconst moveRight = (u, amt = 7) => (Object.assign(Object.assign({}, u), { x: u.x < (canvasWidth - playerWidth) ? u.x += amt : (canvasWidth - playerWidth) }));\nconst moveUp = (u, amt = 7) => (Object.assign(Object.assign({}, u), { y: u.y >= (0) ? u.y -= amt : playerHeight }));\nconst moveDown = (u, amt = 7) => (Object.assign(Object.assign({}, u), { y: u.y <= (canvasHeight) ? u.y += amt : (canvasHeight) }));\nconst createShot = (opts = {}) => {\n    return (Object.assign({ objectID: objectID(), name: 'shot', x: 0, y: 0, radius: 0, dr: (time, shot, index) => {\n            const maxRadius = floor(canvasWidth / 3);\n            const progress = (+new Date - shot.start) / (shot.duration);\n            if (progress > 1) {\n                return 0;\n            }\n            return floor(maxRadius * progress);\n        }, start: (+new Date), duration: 2000 }, opts));\n};\nconst createPlayer = () => {\n    return ({ objectID: objectID(),\n        name: 'player',\n        width: playerWidth,\n        height: playerHeight,\n        x: (canvasWidth) / 2,\n        y: canvasHeight / 5,\n        volume: 100,\n        speed: 100,\n        luck: 100\n    });\n};\nconst createDrone = (defaults = {}) => {\n    const bias = 0.7; // favor the center of the room\n    return Object.assign({ objectID: objectID(),\n        name: 'drone',\n        x: bias * Math.random() * canvasWidth,\n        y: bias * Math.random() * canvasHeight,\n        width: 40,\n        height: 40,\n        lastwalk: false\n    }, defaults);\n};\nconst createOpeningMusicDrops = (qty = 3) => {\n    const drops = [];\n    const containerWidth = canvasWidth * 2 / qty;\n    const offsetWall = canvasWidth / qty;\n    const offsetCeiling = (canvasHeight + elementRadius) / 2;\n    const elWidth = containerWidth / qty;\n    for (let i = 0; i < 3; i++) {\n        const x = offsetWall + (i * elWidth);\n        const y = offsetCeiling;\n        drops.push(createMusicDrop({ x, y, role: Role.bass, clan: Clan[Clan[i]] }));\n    }\n    return drops;\n};\nconst createMusicDrop = (opts = {}) => {\n    return (Object.assign(Object.assign({ clan: '', x: 0, y: 0, radius: elementRadius, dr: (time, element) => floor(elementRadius * abs(sin((element.objectID) + downScale(time)))), width: 0, height: 0 }, opts // do not allow name or objectID to be initialized\n    ), { name: 'element', objectID: objectID() }));\n};\nconst motionControls = () => ({ ArrowRight: moveRight,\n    ArrowLeft: moveLeft,\n    ArrowDown: moveDown,\n    ArrowUp: moveUp\n});\nconst applyMotion = (player, controlKey) => {\n    let map = motionControls();\n    if (!(Object.keys(map).includes(controlKey)))\n        return player;\n    return map[controlKey](player);\n};\n/* Respond to the keydown controls */\nconst applyControls = (time, state) => {\n    const renderOffset = 0;\n    let shots = state.shots;\n    if (game.controls.includes('f')) {\n        shots = shots.concat(createShot({ start: (+new Date), x: state.player.x, y: state.player.y, duration: 200 }));\n        game.controls = game.controls.filter(k => k != 'f');\n    }\n    const isInProgress = (shot) => 1 !== (floor((+new Date) / (shot.start + (shot.duration + renderOffset))));\n    return (Object.assign(Object.assign({}, state), { shots: shots.filter(isInProgress), player: game.controls.reduce(applyMotion, state.player) }));\n};\nconst updateRadial = (unit, time) => {\n    const radius = unit.dr(time, unit);\n    return Object.assign(Object.assign({}, unit), { radius, width: radius / 2, height: radius / 2 });\n};\n/* Update the x,y,width,height,radius properties of units in state. */\nconst applyPositions = (time, state) => {\n    return Object.assign(Object.assign({}, state), { shots: state.shots.map((u) => updateRadial(u, +new Date)), drops: state.drops.map((u) => updateRadial(u, time)), drones: state.drones.map(walk) });\n};\nconst applyToTree = (tree, u) => {\n    tree.insert(u);\n    return tree;\n};\n/* Global handler for store state updates */\nconst updateTreeIndices = (time, state, tree) => {\n    return ([state.player,\n        ...state.drones,\n        ...state.drops,\n        ...state.shots]).reduce(applyToTree, tree);\n};\nconst handlePlayerCollisions = (state, tree) => {\n    const droneHits = state.drones.reduce((collisions, drone) => {\n        const intersections = tree.retrieve(drone).filter((unit) => collides(unit, drone));\n        return collisions.concat(intersections);\n    }, []);\n    const playerHits = tree.retrieve(state.player).filter((u) => collides(u, state.player));\n    return [...playerHits, ...droneHits];\n};\nconst applyShotCollisions = (state, tree) => {\n    const allTouches = state.shots.map(shot => tree.retrieve(shot));\n    const touches = allTouches.reduce((a, x) => [...a, ...x], []);\n    const defenderIDs = touches.map(drone => drone.objectID);\n    // destroy on contact\n    const drones = state.drones.filter(drone => !defenderIDs.includes(drone.objectID));\n    return Object.assign(Object.assign({}, state), { drones });\n};\nconst addToEnsemble = (ensemble, clan, key, amt = 2) => {\n    if (ensemble[key].clan != clan) {\n        const preset = Presets[clan];\n        // Swap the previous type with the new one\n        ensemble[key].clan = clan;\n        ensemble[key].volume = amt;\n        ensemble[key].bpm = preset.bpm;\n        ensemble[key].tonic = preset.tonic;\n        ensemble[key].melody = preset.voices[key];\n    }\n    else {\n        ensemble[key].volume += amt;\n    }\n    return ensemble;\n};\nfunction getSynth(role) {\n    const roles = { [Role.bass]: _Sequencer__WEBPACK_IMPORTED_MODULE_1__[\"partBass\"],\n        [Role.tenor]: _Sequencer__WEBPACK_IMPORTED_MODULE_1__[\"partHarmony\"],\n        [Role.alto]: _Sequencer__WEBPACK_IMPORTED_MODULE_1__[\"partLead\"],\n        [Role.soprano]: _Sequencer__WEBPACK_IMPORTED_MODULE_1__[\"partHarmony\"]\n    };\n    return (roles[role] || _Sequencer__WEBPACK_IMPORTED_MODULE_1__[\"partHarmony\"]);\n}\n// reindexes the list to start at `index`\nfunction beatmatch(index, list) {\n    return [...list.concat().slice(index, list.length), ...list.concat().slice(0, index)];\n}\nconst choppy = x => 0.5;\nconst shortening = x => {\n    let duration = 1 / (x + 1);\n    return duration;\n};\nconst tenuto = x => 0.85;\nconst sostenuto = x => 0.99;\nconst getDuration = (role) => {\n    const roles = { [Role.bass]: choppy,\n        [Role.tenor]: tenuto,\n        [Role.alto]: shortening,\n        [Role.soprano]: sostenuto\n    };\n    return (roles[role] || tenuto);\n};\nfunction game() {\n    const controls = [];\n    const state = { player: createPlayer(), ensemble: { [Role.bass]: { volume: 1 },\n            [Role.tenor]: { volume: 1 },\n            [Role.alto]: { volume: 1 },\n            [Role.soprano]: { volume: 1 }\n        }, drones: [],\n        shots: [],\n        drops: createOpeningMusicDrops(), room: { clan: null, role: Role.bass }, level: 0 };\n    const play = (now, role, part) => {\n        var _a;\n        if (part.volume == 1) {\n            if (typeof part.sequencer != 'undefined') {\n                part.sequencer.stop();\n                delete part.sequencer;\n            }\n            return;\n        }\n        const synth = getSynth(role);\n        const beat = Object(_Sequencer__WEBPACK_IMPORTED_MODULE_1__[\"getBeatIndex\"])(now, part.bpm, part.melody);\n        // start the first one\n        if (typeof part.sequencer == 'undefined') {\n            const notes = Object(_Sequencer__WEBPACK_IMPORTED_MODULE_1__[\"intervalsToMelody\"])(part.tonic, getDuration(role), beatmatch(beat, part.melody));\n            const play = synth(now, part.bpm, notes);\n            part.sequencer = play();\n            part.sequencer.osc.onended = () => {\n                delete part.sequencer;\n            };\n            return;\n        }\n        // set up the next loop\n        if ((typeof ((_a = part === null || part === void 0 ? void 0 : part.sequencer) === null || _a === void 0 ? void 0 : _a.osc.onended) == 'undefined') && beat == (part.melody.length - 1)) {\n            const beatWidth = Object(_Sequencer__WEBPACK_IMPORTED_MODULE_1__[\"getBeatLength\"])(part.bpm);\n            const notes = Object(_Sequencer__WEBPACK_IMPORTED_MODULE_1__[\"intervalsToMelody\"])(part.tonic, getDuration(role), part.melody);\n            part.sequencer.osc.onended = () => {\n                delete part.sequencer;\n            };\n        }\n    };\n    const playMusicEnsemble = (now, ensemble) => {\n        Object.entries(ensemble).forEach(([key, part]) => play(now, parseInt(key), part));\n    };\n    const updateSound = (state, ctx) => {\n        const { ensemble } = state;\n        // if ( state.level == 0 ) {\n        //   playMusicEnsemble(ctx.currentTime, Songs.opening)\n        // } else {\n        playMusicEnsemble(ctx.currentTime, state.ensemble);\n        // }\n    };\n    const drawNPCS = (time, state) => {\n        const cAttrs = clanAttributes[state.room.clan];\n        const rAttrs = roleAttributes[state.room.role];\n        // use measuretext here because it depends on the ctx\n        // it is a sidefx that should go in applyMotion instead\n        return (ctx) => {\n            state.drones.forEach((drone, i) => {\n                const { x, y } = drone;\n                const text = rAttrs.text.repeat(2);\n                const metrics = ctx.measureText(text);\n                drone.width = metrics.width;\n                ctx.fillStyle = toColor(cAttrs.rgb, rAttrs.colorMod);\n                ctx.fillText(text, floor(x + droneWidth), floor(y + droneHeight));\n            });\n        };\n    };\n    const drawShots = (time, state) => {\n        return (ctx) => {\n            state.shots.forEach((shot, i) => {\n                ctx.strokeStyle = toColor([(shot.x + shot.y) % 100, shot.x % 255, shot.y % 200]);\n                ctx.arc(shot.x, shot.y, shot.radius, 0, 2 * PI);\n                ctx.lineWidth = (time % 20);\n                ctx.stroke();\n            });\n        };\n    };\n    const drawDrops = (time, state) => {\n        const rgb = [0, 0, 0];\n        return (ctx) => {\n            drawDoors(ctx, state.room.clan);\n            state.drops.forEach(({ x, y, width, height }, i) => {\n                for (let j = 0; j < 3; j++) {\n                    rgb[i] = 255;\n                    const offset = +downScale(time) + (PI * j / 4);\n                    const endpoint = (Math.PI / 4) + offset;\n                    ctx.fillStyle = toColor(rgb);\n                    ctx.arc(x, y, 30, offset, endpoint);\n                    ctx.stroke();\n                    ctx.fill();\n                }\n            });\n        };\n    };\n    const drawPlayer = (time, state) => {\n        const mainColor = 'white';\n        const accent = 'black';\n        const text = '!*!' || false;\n        return (ctx) => {\n            const metrics = ctx.measureText(text);\n            state.player.height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;\n            state.player.width = metrics.width;\n            // Must apply width and height using the ctx\n            ctx.fillStyle = mainColor;\n            ctx.strokeStyle = accent;\n            ctx.strokeText(text, state.player.x, state.player.y);\n            ctx.fillText(text, state.player.x, state.player.y);\n        };\n    };\n    const drawTiles = (time, ctx, state) => {\n        let tw = 30;\n        let th = 30;\n        let nx = canvasWidth / tw;\n        let ny = canvasHeight / th;\n        for (let i = 0; i < nx; i++) {\n            let r = (i * downScale(time, 3)) % 255;\n            // let r = useMod(i,time,state)\n            for (let j = 0; j < ny; j++) {\n                let g = useMod(j, time, state);\n                let b = useMod(i + j, time, state);\n                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;\n                ctx.fillRect(i * tw - i, j * th - j, i * tw + tw, j * tw + tw);\n            }\n        }\n    };\n    const drawTiles2 = (time, ctx) => {\n        let tw = 20;\n        let th = 20;\n        let nx = canvasWidth / tw;\n        let ny = canvasHeight / th;\n        for (let i = 0; i < nx; i++) {\n            let r = (i * downScale(time, 1)) % 255;\n            for (let j = 0; j < ny; j++) {\n                let g = (j * downScale(time, 2)) % 255;\n                let b = (i + j * downScale(time, 4)) % 255;\n                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;\n                ctx.fillRect(i * tw - i, j * th - j, i * tw + tw, j * tw + tw);\n            }\n        }\n    };\n    const drawTiles3 = (time, ctx) => {\n        let tw = 20;\n        let th = 20;\n        let nx = canvasWidth / tw;\n        let ny = canvasHeight / th;\n        for (let i = 0; i < nx; i++) {\n            let r = (i * downScale(time, 1 + time % 5)) % 255;\n            for (let j = 0; j < ny; j++) {\n                let g = (j * downScale(time, time % 2)) % 255;\n                let b = (i + j * downScale(time, time % 4)) % 255;\n                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;\n                ctx.fillRect(i * tw - i, j * th - j, i * tw + tw, j * tw + tw);\n            }\n        }\n    };\n    const drawTiles4 = (time, ctx) => {\n        let tw = time % 200;\n        let th = time % 100;\n        let nx = canvasWidth / tw;\n        let ny = canvasHeight / th;\n        for (let i = 0; i < nx; i++) {\n            let r = (i * downScale(time, 1 + time % 5)) % 255;\n            for (let j = 0; j < ny; j++) {\n                let g = (j * downScale(time, time % 2)) % 255;\n                let b = (i + j * downScale(time, time % 4)) % 255;\n                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;\n                ctx.fillRect(i * tw - i, j * th - j, i * tw + tw, j * tw + tw);\n            }\n        }\n    };\n    const drawDoors = (ctx, clan) => {\n        let altClans = Object.keys(Clan).map(a => parseInt(a)).filter(c => c !== clan).filter(aN);\n        let doorHeight = 40;\n        let offsetWall = 0;\n        let doorWidth = 20;\n        let offsetCeiling = (canvasHeight - doorHeight) / 3;\n        // left door\n        ctx.fillStyle = toColor(clanAttributes[altClans[0]].rgb);\n        ctx.fillRect(offsetWall, offsetCeiling, offsetWall + doorWidth, offsetCeiling + doorHeight);\n        // right door\n        ctx.fillStyle = toColor(clanAttributes[altClans[1]].rgb);\n        ctx.fillRect(canvasWidth - offsetWall - doorWidth, offsetCeiling, canvasWidth - offsetWall + doorWidth, offsetCeiling + doorHeight);\n    };\n    const drawRoom = (time, state) => {\n        // let selection = floor(downScale(time,3))%4\n        // let render = (\n        //   [ drawTiles\n        //   , drawTiles2\n        //   , drawTiles3\n        //   , drawTiles4\n        //   ])[selection]\n        return (ctx) => {\n            drawTiles(time, ctx, state);\n        };\n    };\n    const drawEnsembleOverlay = (time, state) => {\n        return (ctx) => {\n        };\n    };\n    const addControlKey = (key) => {\n        return controls.includes(key) ? controls : controls.concat(key);\n    };\n    const removeControlKey = (key) => controls.filter(k => k !== key);\n    const handleKeydown = (e, time, state) => {\n        if (e.repeat === true) {\n            return;\n        }\n        if (e.key == 'f' && game.controls.includes(e.key)) {\n            game.controls = game.controls.filter(k => k !== e.key);\n        }\n        else {\n            game.controls = game.controls.concat(e.key);\n        }\n        const remove = () => {\n            game.controls = game.controls.filter(k => k !== e.key);\n        };\n        const cleanup = (ev) => {\n            if (e.key === ev.key) {\n                remove();\n                window.removeEventListener('keyup', cleanup);\n            }\n        };\n        window.addEventListener('keyup', cleanup);\n    };\n    const getDrones = (qty = 4, drones = []) => {\n        if (qty === 0)\n            return drones;\n        drones = drones.concat(createDrone());\n        return getDrones(qty - 1, drones);\n    };\n    const drawStage = (time, state, illustrate) => {\n        illustrate((ctx) => ctx.clearRect(0, 0, canvasWidth, canvasHeight));\n        if (state.level == 0) {\n            openingScene(time, state, illustrate);\n            illustrate(drawShots(time, state));\n            return;\n        }\n        if (state.drops.length > 0) {\n            dropScene(time, state, illustrate);\n        }\n        else {\n            swarmScene(time, state, illustrate);\n        }\n    };\n    const swarmScene = (time, state, illustrate) => {\n        illustrate(drawRoom(time, state));\n        illustrate(drawNPCS(time, state));\n        illustrate(drawShots(time, state));\n        illustrate(drawPlayer(time, state));\n    };\n    const dropScene = (time, state, illustrate) => {\n        // illustrate( drawRoom(time, state) )\n        illustrate(drawDrops(time, state));\n        illustrate(drawPlayer(time, state));\n    };\n    const updateListeners = (time, state) => {\n        const listener = (e) => handleKeydown(e, time, state);\n        if (typeof updateListeners.prev == 'function')\n            window.removeEventListener('keydown', updateListeners.prev);\n        window.addEventListener('keydown', updateListeners.prev = listener);\n        return state;\n    };\n    const applyPlayerCollisions = (state, touches, type = '') => {\n        if (type === '')\n            type = touches[0].name;\n        const action = touchHandlers[type];\n        if (typeof action == 'undefined') {\n            // TODO applyPlayerCollisions sould be explicitly called with known arguments\n            return state;\n        }\n        return action(state, touches);\n    };\n    const enumKeys = (e) => Object.keys(e).map(a => parseInt(a)).filter(aN);\n    /** Create a room with new values compared to a previous room. */\n    const nextRoom = (pClan, pRole) => {\n        const altClans = enumKeys(Clan).filter(k => k != pClan);\n        const altRoles = enumKeys(Role).filter(k => k != pRole);\n        const clan = altClans[randomInt(0, altClans.length - 1)];\n        const role = altRoles[randomInt(0, altRoles.length - 1)];\n        return { clan, role };\n    };\n    const setupNextLevel = (state) => {\n        const room = nextRoom(state.room.clan, state.room.role);\n        const drones = getDrones(state.level * 2);\n        return Object.assign(Object.assign({}, state), { drones, room });\n    };\n    const setupDrops = (state) => {\n        // const unit = f({x, y, width: radius, height: radius, clan: Clan[i]})\n        const element = createMusicDrop({ name: 'element',\n            x: canvasWidth / 2,\n            y: canvasHeight / 2,\n            clan: state.room.clan,\n            role: state.room.role\n        });\n        return Object.assign(Object.assign({}, state), { drops: [element] });\n    };\n    const loop = (time, prev, draw, tree) => {\n        tree.clear();\n        let next = applyControls(time, prev);\n        next = applyPositions(time, next);\n        tree = updateTreeIndices(time, next, tree);\n        updateSound(next, _Sequencer__WEBPACK_IMPORTED_MODULE_1__[\"ac\"]);\n        let collisions = handlePlayerCollisions(next, tree);\n        if (collisions.length > 0) {\n            next = applyPlayerCollisions(next, collisions);\n        }\n        if (next.shots.length > 0 && next.drones.length > 0) {\n            // shoot at the drones, remove the hits\n            let drones = next.shots.reduce((drones, shot, i) => {\n                const collisions = tree.retrieve(shot).filter((unit) => collides(unit, shot));\n                return drones.filter(drone => !collisions.includes(drone));\n            }, next.drones);\n            // next = applyShotCollisions(next, tree)\n            next = Object.assign(Object.assign({}, next), { drones });\n        }\n        // you died\n        if (Object.values(next.ensemble).some(part => part.volume == 0)) {\n            location.reload();\n        }\n        if (prev.level != next.level) {\n            next = setupNextLevel(next);\n        }\n        else if (next.drones.length == 0 && next.drops.length == 0) {\n            // The room is clear, provide the drops\n            next = setupDrops(next);\n        }\n        updateListeners(time, next);\n        drawStage(time, next, draw);\n        requestAnimationFrame((ntime) => loop(ntime, next, draw, tree));\n    };\n    const playback = (state, tick, config) => {\n        const { canvasWidth, canvasHeight } = config;\n        const canvas = document.createElement('canvas');\n        canvas.width = canvasWidth;\n        canvas.height = canvasHeight;\n        const ctx = canvas.getContext('2d');\n        ctx.font = '50px monospace';\n        document.body.appendChild(canvas);\n        const scene = (draw) => {\n            ctx.beginPath();\n            ctx.lineWidth = 8;\n            draw(ctx);\n            ctx.closePath();\n        };\n        const tree = Object(_store__WEBPACK_IMPORTED_MODULE_0__[\"Quadtree\"])({ x: 0, y: 0, width: canvasWidth, height: canvasHeight }, 3, 4);\n        tick(0, state, scene, tree);\n    };\n    const openingScene = (time, state, illustrate) => {\n        const clans = enumKeys(Clan);\n        const containerWidth = canvasWidth * 2 / 3;\n        const offsetWall = canvasWidth / 3;\n        const offsetCeiling = canvasHeight / 3;\n        const elWidth = containerWidth / clans.length;\n        illustrate((ctx) => drawTiles(time, ctx, state));\n        state.drops.forEach((unit, i) => {\n            illustrate((ctx) => {\n                const attrs = clanAttributes[i];\n                const rAttrs = roleAttributes[i];\n                ctx.fillStyle = ctx.strokeStyle = toColor(attrs.rgb, rAttrs[i]);\n                ctx.arc(unit.x, unit.y, unit.radius, 0, 2 * Math.PI);\n                ctx.fill();\n                ctx.stroke();\n            });\n        });\n        illustrate(drawPlayer(time, state));\n    };\n    playback(state, loop, config);\n}\nconst getSoundtrackParts = (clan, role) => {\n    const notes = [];\n    return notes;\n};\n/**\nthe game state must be aware of current global baseline bpm and measure number\nit does not need a record of it\n\n\n*/\n// todo decide if it is worth having a global async controls or use something else\ngame.controls = [];\ngame();\n\n\n//# sourceURL=webpack:///./src/index.ts?");

/***/ }),

/***/ "./src/store.ts":
/*!**********************!*\
  !*** ./src/store.ts ***!
  \**********************/
/*! exports provided: Quadtree */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Quadtree\", function() { return Quadtree; });\nfunction Quadtree(bounds, limits = 4, depth = 10, level = 0, objects = [], nodes = []) {\n    let insert = o => {\n        var i = 0, indexes;\n        //if we have subnodes, call insert on matching subnodes\n        if (nodes.length) {\n            indexes = getIndex(o);\n            for (i = 0; i < indexes.length; i++) {\n                nodes[indexes[i]].insert(o);\n            }\n            return o;\n        }\n        //otherwise, store object here\n        objects.push(o);\n        //limits reached\n        if (objects.length > limits && level < depth) {\n            //split if we don't already have subnodes\n            if (!nodes.length) {\n                //@ts-ignore\n                split();\n            }\n            //add all objects to their corresponding subnode\n            for (i = 0; i < objects.length; i++) {\n                indexes = getIndex(objects[i]);\n                for (var k = 0; k < indexes.length; k++) {\n                    nodes[indexes[k]].insert(objects[i]);\n                }\n            }\n            //clean up this node\n            objects = [];\n        }\n        return o;\n    };\n    let retrieve = o => {\n        var indexes = getIndex(o), returnObjects = objects;\n        //if we have subnofdes, retrieve their objects\n        if (nodes.length) {\n            for (var i = 0; i < indexes.length; i++) {\n                returnObjects = returnObjects.concat(nodes[indexes[i]].retrieve(o));\n            }\n        }\n        //remove duplicates\n        returnObjects = returnObjects.filter(function (item, index) {\n            return returnObjects.indexOf(item) >= index;\n        });\n        return returnObjects;\n    };\n    let getIndex = o => {\n        var indexes = [], verticalMidpoint = bounds.x + (bounds.width / 2), horizontalMidpoint = bounds.y + (bounds.height / 2);\n        var startIsNorth = o.y < horizontalMidpoint, startIsWest = o.x < verticalMidpoint, endIsEast = o.x + o.width > verticalMidpoint, endIsSouth = o.y + o.height > horizontalMidpoint;\n        //top-right quad\n        if (startIsNorth && endIsEast) {\n            indexes.push(0);\n        }\n        //top-left quad\n        if (startIsWest && startIsNorth) {\n            indexes.push(1);\n        }\n        //bottom-left quad\n        if (startIsWest && endIsSouth) {\n            indexes.push(2);\n        }\n        //bottom-right quad\n        if (endIsEast && endIsSouth) {\n            indexes.push(3);\n        }\n        return indexes;\n    };\n    let split = _ => {\n        var next = level + 1, width = bounds.width / 2, height = bounds.height / 2, x = bounds.x, y = bounds.y;\n        const make = (x, y) => (Quadtree({ x, y, width, height }));\n        //top right node\n        nodes[0] = make(x + width, y);\n        //top left node\n        nodes[1] = make(x, y);\n        //bottom left node\n        nodes[2] = make(x, y + height);\n        //bottom right node\n        nodes[3] = make(x + width, y + width);\n    };\n    let clear = _ => {\n        objects = [];\n        for (let i = 0; i < nodes.length; i++) {\n            if (nodes.length) {\n                nodes[i].clear();\n            }\n        }\n        nodes = [];\n    };\n    return { insert, retrieve, getIndex, split, clear };\n}\n\n\n//# sourceURL=webpack:///./src/store.ts?");

/***/ })

/******/ });