/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/Sequencer.ts":
/*!**************************!*\
  !*** ./src/Sequencer.ts ***!
  \**************************/
/*! exports provided: transpose, ac, S, intervalsToMelody, partLead, partHat, partKick, getBeatIndex, getBeatLength, getStartOfNextBar */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transpose\", function() { return transpose; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ac\", function() { return ac; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"S\", function() { return S; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"intervalsToMelody\", function() { return intervalsToMelody; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"partLead\", function() { return partLead; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"partHat\", function() { return partHat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"partKick\", function() { return partKick; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getBeatIndex\", function() { return getBeatIndex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getBeatLength\", function() { return getBeatLength; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getStartOfNextBar\", function() { return getStartOfNextBar; });\nlet transpositionMap = (rising = true) => [1, (16 / 15), (9 / 8), (6 / 5), (5 / 4), (4 / 3), rising ? (45 / 32) : (25 / 18)];\nlet transpose = (freq, steps) => {\n    // Use `NaN` to represent a rest\n    if (isNaN(freq))\n        return 1;\n    let modTable = transpositionMap();\n    let bound = modTable.length - 1;\n    if (steps <= bound) {\n        return freq * modTable[steps];\n    }\n    steps = steps - bound;\n    return transpose(transpose(freq, bound), steps);\n};\nvar ac = new AudioContext();\nfunction Note(freq, duration) {\n    return [freq, duration];\n}\nfunction S(tempo, notes = []) {\n    this.ac = ac;\n    this.createFxNodes();\n    this.fx = [];\n    this.tempo = tempo || 120;\n    this.loop = true;\n    this.smoothing = 0;\n    this.staccato = 0;\n    this.notes = notes;\n}\n// create gain and EQ nodes, then connect 'em\nS.prototype.createFxNodes = function () {\n    let prev = this.gain = this.ac.createGain();\n    this.lp = this.ac.createBiquadFilter();\n    this.lp.type = 'lowpass';\n    this.lp.frequency.value = 22000;\n    prev.connect(prev = this.lp);\n    this.hp = this.ac.createBiquadFilter();\n    this.hp.type = 'highpass';\n    this.hp.frequency.value = 80;\n    prev.connect(prev = this.hp);\n    prev.connect(this.ac.destination);\n    return this;\n};\n// recreate the.oillator node (happens on every play)\nS.prototype.createOscillator = function () {\n    this.stop();\n    this.o = this.ac.createOscillator();\n    this.o.type = this.shape;\n    this.gain.value = 0.2;\n    if (this.role == 'kick') {\n        var dis = this.ac.createWaveShaper();\n        dis.curve = disCurve(400);\n        dis.oversample = '4x';\n        this.o.connect(dis);\n        dis.connect(ac.destination);\n        return this;\n    }\n    this.o.connect(this.gain);\n    this.o.connect(ac.destination);\n    return this;\n};\n// schedules this.notes[ index ] to play at the given time\n// returns an AudioContext timestamp of t the note will *end*\nS.prototype.scheduleNote = function (index, t) {\n    var duration = 60 / this.tempo * this.notes[index][1], cutoff = duration * (1 - (this.staccato || 0));\n    this.setFrequency(this.notes[index][0], t);\n    if (this.smoothing && this.notes[index][0]) {\n        this.slide(index, t, cutoff);\n    }\n    if (this.role == 'kick') {\n        this.o.frequency.exponentialRampToValueAtTime(1, t + cutoff);\n    }\n    else {\n        this.setFrequency(0, t + cutoff);\n    }\n    return t + duration;\n};\n// get the next note\nS.prototype.getNextNote = function (index) {\n    return this.notes[index < this.notes.length - 1 ? index + 1 : 0];\n};\n// how long do we wait before beginning the slide? (in seconds)\nS.prototype.getSlideStartDelay = function (width) {\n    return width - Math.min(width, 60 / this.tempo * this.smoothing);\n};\n// slide the note at <index> into the next note at the given time,\n// and apply staccato effect if needed\nS.prototype.slide = function (index, t, cutoff) {\n    var next = this.getNextNote(index), start = this.getSlideStartDelay(cutoff);\n    this.setFrequency(this.notes[index][0], t + start);\n    this.rampFrequency(next[0], t + cutoff);\n    return this;\n};\nS.prototype.setFrequency = function (freq, t) {\n    if (this.o instanceof OscillatorNode) {\n        this.o.frequency.setValueAtTime(freq, t);\n    }\n    return this;\n};\nS.prototype.rampFrequency = function (freq, t) {\n    this.o.frequency.linearRampToValueAtTime(freq, t);\n    return this;\n};\n// run through all notes in the sequence and schedule them\nS.prototype.play = function (t) {\n    t = (typeof t === 'number') ? t : this.ac.currentTime;\n    this.createOscillator();\n    this.o.start(t + 1);\n    this.notes.forEach(function (note, i) {\n        t = this.scheduleNote(i, t);\n    }.bind(this));\n    this.o.stop(t);\n    return this;\n};\n// stop playback, null out the.oillator, cancel parameter automation\nS.prototype.stop = function () {\n    if (this.o instanceof OscillatorNode) {\n        this.o.stop(0);\n        this.o.frequency.cancelScheduledValues(0);\n        this.o = null;\n    }\n    return this;\n};\nvar intervalsToMelody = (root, duration = (i) => 1, intervals = []) => intervals.map((interval, i) => ([isNaN(interval) ? 0 : transpose(root, interval), duration(i)]));\nvar partLead = (t, tempo, melody) => {\n    var seq = new S(tempo, melody);\n    seq.staccato = 0.55;\n    seq.gain.gain.value = 1.0;\n    seq.type = 'sawtooth';\n    seq.hp.frequency.value = 1200;\n    seq.role = 'lead';\n    return function play() {\n        seq.play(t);\n        return seq;\n    };\n};\nvar partHat = (when, tempo, melody) => {\n    const seq = new S(tempo, melody);\n    seq.staccato = 0.55;\n    seq.gain.gain.value = 1.0;\n    seq.type = 'triangle';\n    return function play() {\n        seq.play(when);\n        return seq;\n    };\n};\n// export var partHat = (t, tempo, melody: Note[]) => {\n//   var seq = new S(tempo, melody);\n//   seq.staccato = 0.55;\n//   seq.gain.gain.value = -20.0;\n//   seq.shape = 'square'\n//   seq.role = 'hat'\n//   seq.hp.frequency.value = 19000\n//   seq.lp.frequency.value = 22000\n//   return function play() {\n//     seq.play(t)\n//     return seq\n//   }\n// }\nvar partKick = (t, tempo, melody) => {\n    var seq = new S(tempo, melody);\n    seq.gain.gain.value = 0.65;\n    seq.gain.gain.value = 0.1;\n    seq.role = 'kick';\n    seq.shape = 'sine';\n    seq.lp.frequency.value = 240;\n    seq.hp.frequency.value = 32;\n    return function play() {\n        seq.play(t);\n        return seq;\n    };\n};\nfunction getBeatIndex(time, bpm, notes = []) {\n    var width = getBeatLength(bpm);\n    var height = width * notes.length;\n    var z = time % height;\n    return notes.findIndex((note, i) => z <= ((i + 1) * width));\n}\nvar getBeatLength = bpm => (60 / bpm);\nfunction getStartOfNextBar(time, bpm, notes) {\n    let currentIndex = getBeatIndex(time, bpm, notes);\n    var beatWidth = getBeatLength(bpm);\n}\nfunction disCurve(amt = 50) {\n    var n = 44100, c = new Float32Array(n), deg = Math.PI / 180, i = 0, x;\n    for (; i < n; ++i) {\n        x = i * 2 / n - 1;\n        c[i] = (3 + amt) * x * 20 * deg / (Math.PI + amt * Math.abs(x));\n    }\n    return c;\n}\n;\n\n\n//# sourceURL=webpack:///./src/Sequencer.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./store */ \"./src/store.ts\");\n/* harmony import */ var _Sequencer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Sequencer */ \"./src/Sequencer.ts\");\n\n\nconst { abs, sin, cos, pow, sqrt, floor, ceil, random, PI, max, min } = Math;\nvar Role;\n(function (Role) {\n    Role[Role[\"kick\"] = 0] = \"kick\";\n    Role[Role[\"tenor\"] = 1] = \"tenor\";\n    Role[Role[\"alto\"] = 2] = \"alto\";\n    Role[Role[\"hat\"] = 3] = \"hat\";\n})(Role || (Role = {}));\nvar Clan;\n(function (Clan) {\n    Clan[Clan[\"B\"] = 0] = \"B\";\n    Clan[Clan[\"C\"] = 1] = \"C\";\n    Clan[Clan[\"A\"] = 2] = \"A\";\n})(Clan || (Clan = {}));\n// # Game Data \nconst clanAttributes = { [Clan.C]: { rgb: [255, 0, 0]\n    },\n    [Clan.B]: { rgb: [0, 0, 255]\n    },\n    [Clan.A]: { rgb: [0, 255, 0]\n    }\n};\nconst roleAttributes = { [Role.kick]: { colorMod(n, time) { return time % 2 ? 255 : 0; },\n        text: 'K',\n        rgb: [255, 50, 0]\n    },\n    [Role.tenor]: { colorMod(n, time) { return time % 2 ? 255 : 0; },\n        text: 'T',\n        rgb: [255, 250, 0]\n    },\n    [Role.alto]: { colorMod(n, time) { return n == 255 ? 175 : n; },\n        text: 'A',\n        rgb: [0, 250, 50]\n    },\n    [Role.hat]: { colorMod(n, time) { return 255; },\n        text: 'H',\n        rgb: [0, 250, 255]\n    }\n};\nconst Presets = { [Clan.A]: { tonic: 88,\n        bpm: 70,\n        voices: { [Role.kick]: [0, 5, 0, 7],\n            [Role.tenor]: [4, 7, 2, 5],\n            [Role.alto]: [12, 4, 0],\n            [Role.hat]: [12, 4, 0, 12, 7, 0, 4, 7]\n        }\n    },\n    [Clan.B]: { tonic: (88 * 4 / 3),\n        bpm: 10.5,\n        voices: { [Role.kick]: [7, 0, 4, 12, 0, 0, 0, 12],\n            [Role.tenor]: [4, 0, 4],\n            [Role.alto]: [0, 4, 7],\n            [Role.hat]: [10, 0, 0, 10, 12, 11, 9, 0]\n        }\n    },\n    [Clan.C]: { tonic: (88 * 5 / 4),\n        bpm: 140,\n        voices: { [Role.kick]: [0, 12, 7, 0],\n            [Role.tenor]: [12, 4, 7],\n            [Role.alto]: [7, 4, 7, 0],\n            [Role.hat]: [10, 0, 0, 10, 12, 11, 9, 0]\n        }\n    }\n};\nconst mods = [(t, x) => scale(t, (x * 2) + 5),\n    (t, x) => scale(t, 51 + x),\n    (t, x) => scale(t, 91 - x),\n    (t, x) => t / x,\n    (t, x) => scale(t, 4) / x,\n    (t, x) => scale(t, 3) / ((x + 1) * 2),\n    (t, x) => x + 100,\n    (t, x) => t - (x * 5),\n    (t, x) => t + 223 % 20];\nconst useMod = (n, time, level) => floor(mods[n % mods.length](time, level)) % 255;\n/**\n * Create an object with new properties from previous object\n *\n * Golfy workaround for game 13k submission\n * Since the spread operator is compiled to `Object._()`,\n * this lets us name our own copy of the method.\n */\nconst _ = (params, defaults = {}) => Object.assign({}, defaults, params);\nconst collides = (unit, obj) => {\n    if (unit.objectID == obj.objectID)\n        return false;\n    return !(unit.x > obj.x + obj.width ||\n        unit.x + obj.width < obj.x ||\n        unit.y > obj.y + obj.height ||\n        unit.y + obj.height < obj.y);\n};\nconst applyDroneDamage = (role, ensemble) => {\n    const next = Object.assign({}, ensemble);\n    const mirrors = [[Role.kick, Role.hat],\n        [Role.tenor, Role.alto]];\n    let dmg = 0;\n    for (let duo of mirrors) {\n        if (duo.includes(role)) {\n            dmg = (duo[0] == role)\n                ? 1\n                : 2;\n            next[role].volume = next[role].volume - dmg;\n        }\n    }\n    return next;\n};\nconst touchHandlers = { drone(state, touches) {\n        const ensemble = touches.reduce((ensemble, drone) => applyDroneDamage(state.room.role, state.ensemble), touches);\n        const defenderIDs = touches.map(drone => drone.objectID);\n        const drones = state.drones.filter(drone => !defenderIDs.includes(drone.objectID));\n        const pickups = state.pickups.concat(touches.map(drone => createPickup(drone)));\n        return _({ drones, ensemble, pickups }, state);\n    },\n    element(state, touches) {\n        var _a;\n        if (touches.length < 1)\n            return;\n        if (state.level == 0 && touches.length != 1) {\n            // prevent multiple collisions when there are 3 nodes\n            return state;\n        }\n        const room = { clan: ((_a = touches[0]) === null || _a === void 0 ? void 0 : _a.clan) || 0, role: (state.level == 0) ? Role.kick : touches[0].role };\n        return _({ ensemble: addToEnsemble(state.ensemble, room.clan, room.role),\n            room,\n            drops: [],\n            level: state.level + 1 }, state);\n    }, shot(state, touches) {\n        //shot doesn't do anything to the player\n        return state;\n    },\n    pickup(state, touches) {\n        // picks up one at a time\n        const ids = touches.map(pickup => pickup.objectID);\n        const pickups = state.pickups.filter(pickup => !ids.includes(pickup.objectID));\n        const ensemble = addToEnsemble(state.ensemble, state.ensemble[state.room.role].clan || state.room.clan, state.room.role, 1);\n        return _({ ensemble, pickups }, state);\n    } };\n// settings you can tweak to resize the characters and stages\nconst cw = min(1200, window.innerWidth);\nconst ch = min(800, window.innerHeight);\nconst playerHeight = 80;\nconst playerWidth = 80;\nconst droneWidth = 50;\nconst droneHeight = 50;\nconst elementRadius = min(100, cw / 6);\nconst config = {\n    cw,\n    ch // canvas width \n}; // code golf is lame\n/* Global unique ID generator. */\nconst objectID = () => {\n    return objectID.prev++;\n};\nobjectID.prev = 0;\n/* The end of game has been reached, auto-refresh for the player. */\nconst reloadGame = () => {\n    window.location.reload();\n};\n/* Make a big number smaller */\nconst scale = (n, scale = 3) => n * pow(10, -(scale));\n/* Opposite of isNaN */\nconst aN = n => (!isNaN(n) && typeof n == 'number');\n/* Turns an RGB array to an \"rgb(255,255,255)\"\" value */\nconst toColor = (rgb, mod = (n, time) => n) => {\n    if (rgb.length != 3) {\n        return '';\n    }\n    const [r, g, b] = rgb.map(mod).map(n => n.toString());\n    return `rgb(${r},${g},${b})`;\n};\n/* Gets a random integer in your range */\nconst randomInt = (min = 0, max = 1) => floor(random() * (floor(max) - ceil(min) + 1)) + ceil(min);\n/* Random boolean value */\nconst coinToss = () => (Math.random() < 0.5);\n/* Determines if unit is near the canvas edges */\nconst isNearWall = (u, threshold = 0.1) => (u.x <= cw * threshold) && (u.y <= ch * threshold);\n/* Move a unit a random amount in a certain direction */\nconst walk = (u, step = 1) => {\n    let direction = u.lastwalk ? 'x' : 'y';\n    return (Object.assign(Object.assign({}, u), { lastwalk: !u.lastwalk, [direction]: coinToss() ? u[direction] + 1 : u[direction] - 1 }));\n};\nconst moveLeft = (u, amt = 7) => _({ x: u.x > 0 ? u.x -= amt : 0 }, u);\nconst moveRight = (u, amt = 7) => _({ x: u.x < (cw - playerWidth) ? u.x += amt : (cw - playerWidth) }, u);\nconst moveUp = (u, amt = 7) => _({ y: u.y >= (0) ? u.y -= amt : playerHeight }, u);\nconst moveDown = (u, amt = 7) => _({ y: u.y <= (ch) ? u.y += amt : (ch) }, u);\nconst createShot = (opts = {}) => _(opts, { objectID: objectID(),\n    name: 'shot',\n    x: 0,\n    y: 0,\n    radius: 0,\n    dr: (time, shot, index) => {\n        const maxRadius = floor(cw / 3);\n        const progress = (+new Date - shot.start) / (shot.duration);\n        if (progress > 1) {\n            return 0;\n        }\n        return floor(maxRadius * progress);\n    },\n    start: (+new Date),\n    duration: 2000\n});\nconst createPlayer = () => ({ objectID: objectID(),\n    name: 'player',\n    width: playerWidth,\n    height: playerHeight,\n    x: (cw) / 2,\n    y: ch / 5,\n    volume: 100,\n    speed: 100,\n    luck: 100\n});\nconst createDrone = (defaults = {}) => {\n    const bias = 0.7; // favor the center of the room\n    return _({ objectID: objectID(),\n        name: 'drone',\n        x: bias * Math.random() * cw,\n        y: bias * Math.random() * ch,\n        width: 40,\n        height: 40,\n        lastwalk: false\n    }, defaults);\n};\nconst createPickup = (defaults = {}) => _({ objectID: objectID(),\n    name: 'pickup'\n}, defaults);\nconst startup = (qty = 3) => {\n    const drops = [];\n    const containerWidth = cw * 2 / qty;\n    const offsetWall = cw / qty;\n    const offsetCeiling = (ch + elementRadius) / 2;\n    const elWidth = containerWidth / qty;\n    for (let i = 0; i < 3; i++) {\n        const x = offsetWall + (i * elWidth);\n        const y = offsetCeiling;\n        drops.push(createDrop({ x, y, role: Role.kick, clan: Clan[Clan[i]] }));\n    }\n    return drops;\n};\nconst createDrop = (opts = {}) => _(opts, Object.assign(Object.assign({ clan: '', x: 0, y: 0, radius: elementRadius, dr: (time, element) => floor(elementRadius * abs(sin((element.objectID) + scale(time)))), width: 0, height: 0 }, opts // do not allow name or objectID to be initialized\n), { name: 'element', objectID: objectID() }));\nconst motionControls = () => ({ ArrowRight: moveRight,\n    ArrowLeft: moveLeft,\n    ArrowDown: moveDown,\n    ArrowUp: moveUp\n});\nconst applyMotion = (player, controlKey) => {\n    let map = motionControls();\n    if (!(Object.keys(map).includes(controlKey)))\n        return player;\n    return map[controlKey](player);\n};\n/* Respond to the keydown controls */\nconst applyControls = (time, state) => {\n    let shots = state.shots;\n    if (game.controls.includes('f')) {\n        shots = shots.concat(createShot({ start: (+new Date), x: state.player.x, y: state.player.y, duration: 200 }));\n        game.controls = game.controls.filter(k => k != 'f');\n    }\n    const isInProgress = (shot) => 1 !== (floor((+new Date) / (shot.start + (shot.duration))));\n    return _({ shots: shots.filter(isInProgress),\n        player: game.controls.reduce(applyMotion, state.player)\n    }, state);\n};\nconst updateRadial = (unit, time) => {\n    const radius = unit.dr(time, unit);\n    return _({ radius, width: radius / 2, height: radius / 2 }, unit);\n};\n/* Update the x,y,width,height,radius properties of units in state. */\nconst applyPositions = (time, state) => _({ shots: state.shots.map((u) => updateRadial(u, +new Date)),\n    drops: state.drops.map((u) => updateRadial(u, time)),\n    drones: state.drones.map(walk)\n}, state);\nconst applyToTree = (tree, u) => {\n    tree.insert(u);\n    return tree;\n};\n/* Global handler for store state updates */\nconst updateTreeIndices = (time, state, tree) => {\n    return ([state.player,\n        ...state.drones,\n        ...state.drops,\n        ...state.pickups,\n        ...state.shots]).reduce(applyToTree, tree);\n};\nconst handleDroneCollisions = (drones, tree) => drones.reduce((collisions, drone) => {\n    const intersections = tree.retrieve(drone).filter((unit) => collides(unit, drone));\n    return collisions.concat(intersections);\n}, []);\nconst addToEnsemble = (ensemble, clan, key, amt = 2) => {\n    if (ensemble[key].clan != clan) {\n        const preset = Presets[clan];\n        // Swap the previous type with the new one\n        ensemble[key].clan = clan;\n        ensemble[key].volume = amt;\n        ensemble[key].bpm = preset.bpm;\n        ensemble[key].tonic = preset.tonic;\n        ensemble[key].melody = preset.voices[key];\n    }\n    else {\n        ensemble[key].volume += amt;\n    }\n    return ensemble;\n};\nfunction getSynth(role) {\n    const roles = { [Role.kick]: _Sequencer__WEBPACK_IMPORTED_MODULE_1__[\"partKick\"],\n        [Role.tenor]: _Sequencer__WEBPACK_IMPORTED_MODULE_1__[\"partLead\"],\n        [Role.alto]: _Sequencer__WEBPACK_IMPORTED_MODULE_1__[\"partLead\"],\n        [Role.hat]: _Sequencer__WEBPACK_IMPORTED_MODULE_1__[\"partHat\"]\n    };\n    return (roles[role] || _Sequencer__WEBPACK_IMPORTED_MODULE_1__[\"partLead\"]);\n}\nconst choppy = x => 0.5;\nconst shortening = x => {\n    let duration = 1 / (x + 1);\n    return duration;\n};\nconst tenuto = x => (x % 2 == 1) ? 0.85 : 0.5;\nconst sostenuto = x => 0.99;\nconst getDuration = (role) => {\n    const roles = { [Role.kick]: choppy,\n        [Role.tenor]: tenuto,\n        [Role.alto]: sostenuto,\n        [Role.hat]: shortening\n    };\n    return (roles[role] || tenuto);\n};\nfunction game() {\n    const controls = [];\n    const state = { player: createPlayer(), ensemble: { [Role.kick]: { volume: 1 },\n            [Role.tenor]: { volume: 1 },\n            [Role.alto]: { volume: 1 },\n            [Role.hat]: { volume: 1 }\n        }, drones: [],\n        shots: [],\n        pickups: [],\n        drops: startup(), room: { clan: null, role: Role.kick }, level: 0 };\n    const play = (now, role, part) => {\n        var _a;\n        if (part.volume == 1) {\n            if (typeof part.sequencer != 'undefined') {\n                part.sequencer.stop();\n                delete part.sequencer;\n            }\n            return;\n        }\n        const synth = getSynth(role);\n        const beat = Object(_Sequencer__WEBPACK_IMPORTED_MODULE_1__[\"getBeatIndex\"])(now, part.bpm, part.melody);\n        // start the first one\n        if (typeof part.sequencer == 'undefined') {\n            const notes = Object(_Sequencer__WEBPACK_IMPORTED_MODULE_1__[\"intervalsToMelody\"])(part.tonic, getDuration(role), part.melody);\n            const play = synth(now, part.bpm, notes);\n            part.sequencer = play();\n            part.sequencer.o.onended = () => {\n                delete part.sequencer;\n            };\n            return;\n        }\n        // set up the next loop\n        if ((typeof ((_a = part === null || part === void 0 ? void 0 : part.sequencer) === null || _a === void 0 ? void 0 : _a.o.onended) == 'undefined') && beat == (part.melody.length - 1)) {\n            const beatWidth = Object(_Sequencer__WEBPACK_IMPORTED_MODULE_1__[\"getBeatLength\"])(part.bpm);\n            const notes = Object(_Sequencer__WEBPACK_IMPORTED_MODULE_1__[\"intervalsToMelody\"])(part.tonic, getDuration(role), part.melody);\n            part.sequencer.o.onended = () => {\n                delete part.sequencer;\n            };\n        }\n    };\n    const updateSound = (state, ctx) => {\n        Object.entries(state.ensemble).forEach(([key, part]) => play(ctx.currentTime, parseInt(key), part));\n    };\n    const isComplete = ensemble => \n    // @ts-ignore\n    Object.values(ensemble).every(part => part.volume >= 6);\n    const drawNPCS = (time, state) => {\n        const cAttrs = clanAttributes[state.room.clan];\n        const rAttrs = roleAttributes[state.room.role];\n        // use measuretext here because it depends on the ctx\n        // it is a sidefx that should go in applyMotion instead\n        return (ctx) => {\n            ctx.font = '50px monospace';\n            state.drones.forEach((drone, i) => {\n                const { x, y } = drone;\n                const text = rAttrs.text;\n                const metrics = ctx.measureText(text);\n                drone.width = metrics.width;\n                ctx.fillStyle = toColor(cAttrs.rgb, rAttrs.colorMod);\n                ctx.fillText(text, floor(x + droneWidth), floor(y + droneHeight));\n            });\n        };\n    };\n    const drawPickups = (time, state) => {\n        // use measuretext here because it depends on the ctx\n        // it is a sidefx that should go in applyMotion instead\n        return (ctx) => {\n            ctx.font = '50px monospace';\n            state.pickups.forEach((pickup, i) => {\n                const { x, y } = pickup;\n                ctx.fillStyle = 'white';\n                ctx.fillRect(x, y, droneWidth, droneHeight);\n            });\n        };\n    };\n    const drawShots = (time, state) => {\n        return (ctx) => {\n            state.shots.forEach((shot, i) => {\n                ctx.strokeStyle = toColor([(shot.x + shot.y) % 100, shot.x % 255, shot.y % 200]);\n                ctx.arc(shot.x, shot.y, shot.radius, 0, 2 * PI);\n                ctx.lineWidth = (time % 20);\n                ctx.stroke();\n            });\n        };\n    };\n    const drawDrops = (time, state) => {\n        const rgb = [0, 0, 0];\n        return (ctx) => {\n            drawDoors(ctx, state.room.clan);\n            state.drops.forEach(({ x, y, width, height }, i) => {\n                for (let j = 0; j < 3; j++) {\n                    rgb[i] = time / i % 255;\n                    const offset = 0 + scale(time) + (PI * j / 4);\n                    const endpoint = (Math.PI / 4) + offset;\n                    ctx.fillStyle = toColor(rgb);\n                    ctx.arc(x, y, 30, offset, endpoint);\n                    ctx.stroke();\n                    ctx.fill();\n                }\n            });\n        };\n    };\n    const drawUI = (time, state, ill) => {\n        const uiW = 300;\n        const uiH = 200;\n        const orbR = 10;\n        const m = (min(uiW, uiH) - 50) / 4;\n        const qty = 4;\n        const max = 10;\n        // background\n        ill((ctx) => {\n            ctx.font = '15px sans-serif';\n            ctx.lineWidth = 10;\n            ctx.strokeStyle = 'black';\n            ctx.fillStyle = 'rgba(255,255,255,0.3)';\n            ctx.fillRect(15, 15, uiW, uiH);\n            ctx.strokeRect(15, 15, uiW, uiH);\n        });\n        // progress orbs\n        Object.values(state.ensemble).forEach((part, j) => {\n            //@ts-ignore\n            let progress = ceil(part.volume * qty / max) - 1;\n            for (let i = 0; i < 4; i++) {\n                ill((ctx) => {\n                    ctx.lineWidth = 2;\n                    const name = Role[j];\n                    const metrics = ctx.measureText(name);\n                    let y = m + (orbR * 4 * j) + orbR / 2;\n                    let x = 50 + (2 * orbR) + (orbR * 2 * i);\n                    if (i == 0) {\n                        ctx.lineWidth = 1;\n                        ctx.strokeStyle = 'white';\n                        ctx.fillText(name, 50, y);\n                    }\n                    ctx.arc(100 + x, y, orbR, 0, PI * 2);\n                    ctx.strokeStyle = 'white';\n                    ctx.stroke();\n                    if (progress >= i) {\n                        ctx.fillStyle = toColor(roleAttributes[j].rgb);\n                        ctx.fill();\n                    }\n                });\n            }\n        });\n    };\n    const drawPlayer = (time, state) => {\n        const mainColor = 'white';\n        const accent = 'black';\n        const text = '!*!' || false;\n        return (ctx) => {\n            ctx.font = '50px monospace';\n            const metrics = ctx.measureText(text);\n            state.player.height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;\n            state.player.width = metrics.width;\n            // Must apply width and height using the ctx\n            ctx.fillStyle = mainColor;\n            ctx.strokeStyle = accent;\n            ctx.strokeText(text, state.player.x, state.player.y);\n            ctx.fillText(text, state.player.x, state.player.y);\n        };\n    };\n    const dTiles = (time, s, level) => (ctx) => {\n        for (let i = 0; i < cw / s; i++) {\n            let r = (i * scale(time, level + 3)) % 255;\n            for (let j = 0; j < ch / s; j++) {\n                let g = useMod(j, scale(time), level);\n                let b = useMod(j + level, scale(time), level);\n                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;\n                ctx.fillRect(i * s - i, j * s - j, i * s + s, j * s + s);\n            }\n        }\n    };\n    const drawDoors = (ctx, clan) => {\n        let alt = enumKeys(Clan);\n        let y = 40;\n        let x = 0;\n        let doorWidth = 20;\n        let offY = (ch - y) / 3;\n        // left door\n        ctx.fillStyle = toColor(clanAttributes[alt[0]].rgb);\n        ctx.fillRect(x, offY, x + doorWidth, offY + y);\n        // right door\n        ctx.fillStyle = toColor(clanAttributes[alt[1]].rgb);\n        ctx.fillRect(cw - x - doorWidth, offY, cw - x + doorWidth, offY + y);\n    };\n    const addControlKey = (key) => controls.includes(key) ? controls : controls.concat(key);\n    const removeControlKey = (key) => controls.filter(k => k !== key);\n    const handleKeydown = (e, time, state) => {\n        if (e.repeat === true)\n            return;\n        (e.key == 'f' && game.controls.includes(e.key))\n            ? game.controls = game.controls.filter(k => k !== e.key)\n            : game.controls = game.controls.concat(e.key);\n        const remove = () => {\n            game.controls = game.controls.filter(k => k !== e.key);\n        };\n        const cleanup = (ev) => {\n            if (e.key === ev.key) {\n                remove();\n                window.removeEventListener('keyup', cleanup);\n            }\n        };\n        window.addEventListener('keyup', cleanup);\n    };\n    const getDrones = (qty = 4, drones = [], player) => {\n        if (qty === 0)\n            return drones;\n        let drone = createDrone();\n        // prevent collision on spawn\n        return collides(drone, player)\n            ? getDrones(qty, drones, player)\n            : getDrones(qty - 1, drones.concat(drone), player);\n    };\n    const drawStage = (time, state, ill) => {\n        ill((ctx) => ctx.clearRect(0, 0, cw, ch));\n        if (state.level == 0) {\n            ill(dTiles(time + 1500, 30, state.level));\n            openingScene(time, state, ill);\n            ill(drawShots(time, state));\n            drawUI(time, state, ill);\n            return;\n        }\n        state.drops.length > 0\n            ? dropScene(time, state, ill)\n            : swarmScene(time, state, ill);\n        drawUI(time, state, ill);\n    };\n    const swarmScene = (time, state, ill) => {\n        ill(dTiles(time, 30, state.level));\n        ill(drawNPCS(time, state));\n        ill(drawPickups(time, state));\n        ill(drawShots(time, state));\n        ill(drawPlayer(time, state));\n    };\n    const dropScene = (time, state, ill) => {\n        ill(drawDrops(time, state));\n        ill(drawPlayer(time, state));\n    };\n    const updateListeners = (time, state) => {\n        const listener = (e) => handleKeydown(e, time, state);\n        if (typeof updateListeners.prev == 'function')\n            window.removeEventListener('keydown', updateListeners.prev);\n        window.addEventListener('keydown', updateListeners.prev = listener);\n        return state;\n    };\n    const applyPlayerCollisions = (state, tree) => {\n        const hits = tree.retrieve(state.player).filter((unit) => collides(unit, state.player));\n        const next = hits.reduce((next, collider, i, collisions) => _(touchHandlers[collider.name](state, collisions), next), state);\n        return next;\n    };\n    const enumKeys = (e) => Object.keys(e).map(a => parseInt(a)).filter(aN);\n    /** Create a room with new values compared to a previous room. */\n    const nextRoom = (c, level) => {\n        const alt = enumKeys(Clan).filter(k => k != c);\n        // Assign roles based on level for even distribution\n        return {\n            clan: alt[randomInt(0, alt.length - 1)],\n            role: level % 4\n        };\n    };\n    const setupNextLevel = (state) => {\n        const room = nextRoom(state.room.clan, state.level);\n        const drones = getDrones(1 + floor(state.level * 1.5), [], state.player);\n        return _({ drones, room, pickups: [] }, state);\n    };\n    const setupDrops = (state) => {\n        const element = createDrop({ name: 'element',\n            x: cw / 2,\n            y: ch / 2,\n            clan: state.room.clan,\n            role: state.room.role\n        });\n        return _({ drops: [element] }, state);\n    };\n    const loop = (time, prev, draw, tree) => {\n        tree.clear();\n        let next = applyControls(time, prev);\n        next = applyPositions(time, next);\n        tree = updateTreeIndices(time, next, tree);\n        updateSound(next, _Sequencer__WEBPACK_IMPORTED_MODULE_1__[\"ac\"]);\n        next = applyPlayerCollisions(next, tree);\n        if (isComplete(next.ensemble)) {\n            alert('Good job you winner!');\n        }\n        if (next.shots.length > 0 && next.drones.length > 0) {\n            // shoot at the drones\n            let drones = next.shots.reduce((drones, shot, i) => {\n                const collisions = tree.retrieve(shot).filter((unit) => collides(unit, shot));\n                return drones.filter(drone => !collisions.includes(drone));\n            }, next.drones);\n            let hits = next.drones.filter(d => !drones.includes(d));\n            // replace a hit with a pickup\n            let pickups = hits.reduce((pickups, drone, i) => pickups.concat(createPickup(drone)), next.pickups);\n            next = _({ drones, pickups }, next);\n        }\n        // player died \n        if (Object.values(next.ensemble).some(part => part.volume < 1)) {\n            reloadGame();\n        }\n        if (prev.level != next.level) {\n            next = setupNextLevel(next);\n        }\n        else if (next.drones.length == 0 && next.drops.length == 0) {\n            // The room is clear, provide the drops\n            next = setupDrops(next);\n        }\n        updateListeners(time, next);\n        drawStage(time, next, draw);\n        requestAnimationFrame((ntime) => loop(ntime, next, draw, tree));\n    };\n    const playback = (state, tick, config) => {\n        const { cw, ch } = config;\n        const canvas = document.createElement('canvas');\n        canvas.width = cw;\n        canvas.height = ch;\n        let ctx = canvas.getContext('2d');\n        document.body.appendChild(canvas);\n        const scene = (draw) => {\n            ctx.beginPath();\n            ctx.lineWidth = state.level % 4 + 6;\n            draw(ctx);\n            ctx.closePath();\n        };\n        const tree = Object(_store__WEBPACK_IMPORTED_MODULE_0__[\"Quadtree\"])({ x: 0, y: 0, width: cw, height: ch }, 3, 4);\n        tick(0, state, scene, tree);\n    };\n    const openingScene = (time, state, ill) => {\n        const clans = enumKeys(Clan);\n        const width = cw * 2 / 3;\n        const offsetWall = cw / 3;\n        const offsetCeiling = ch / 3;\n        state.drops.forEach((unit, i) => {\n            for (let j = 0; j < 3; j++) {\n                ill((ctx) => {\n                    const attrs = clanAttributes[i];\n                    const rAttrs = roleAttributes[i];\n                    ctx.fillStyle = ctx.strokeStyle = toColor(attrs.rgb);\n                    ctx.arc(unit.x, (scale(time) / (j + 2)) + unit.y, unit.radius, time + j / PI, time + (i * PI / 4) + PI / 4);\n                    ctx.fill();\n                    ctx.stroke();\n                });\n            }\n        });\n        ill(drawPlayer(time, state));\n        ill((ctx) => {\n            ctx.font = '25px sans-serif';\n            ([`Use the arrow keys to move`,\n                `Choose your Bassline`,\n                `Press F to fire`,\n                `Daze the drones to collect their essence`,\n                `Assemble all 4 parts to find your track!`]).reduce((y, t) => (ctx.fillText(t, 50, ch - y), (y - 50)), 250);\n        });\n    };\n    playback(state, loop, config);\n}\n// todo decide if it is worth having a global async controls or use something else\ngame.controls = [];\ngame();\n\n\n//# sourceURL=webpack:///./src/index.ts?");

/***/ }),

/***/ "./src/store.ts":
/*!**********************!*\
  !*** ./src/store.ts ***!
  \**********************/
/*! exports provided: Quadtree */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Quadtree\", function() { return Quadtree; });\n/**\n * uglified quadtree for golfing\n * @param b Bounds\n * @param l limit\n * @param d depth\n * @param lv level\n * @param os objects <T>[]\n * @param ns nodes Quadtree[]\n */\nlet Quadtree = (bounds, limit = 4, depth = 10, level = 0, objects = [], nodes = []) => {\n    let b = bounds, l = limit, d = depth, lv = level, os = objects, ns = nodes;\n    let insert = o => {\n        var i = 0, indexes;\n        //if we have subns, call insert on matching subns\n        if (ns.length) {\n            indexes = getIndex(o);\n            for (i = 0; i < indexes.length; i++) {\n                ns[indexes[i]].insert(o);\n            }\n            return o;\n        }\n        //otherwise, store object here\n        os.push(o);\n        //l reached\n        if (os.length > l && lv < d) {\n            //split if we don't already have subns\n            if (!ns.length) {\n                //@ts-ignore\n                split();\n            }\n            //add all os to their corresponding subnode\n            for (i = 0; i < os.length; i++) {\n                indexes = getIndex(os[i]);\n                for (var k = 0; k < indexes.length; k++) {\n                    ns[indexes[k]].insert(os[i]);\n                }\n            }\n            //clean up this node\n            os = [];\n        }\n        return o;\n    };\n    let retrieve = o => {\n        var indexes = getIndex(o), r = os;\n        //if we have subnofdes, retrieve their os\n        if (ns.length) {\n            for (var i = 0; i < indexes.length; i++) {\n                r = r.concat(ns[indexes[i]].retrieve(o));\n            }\n        }\n        //remove duplicates\n        r = r.filter(function (item, index) {\n            return r.indexOf(item) >= index;\n        });\n        return r;\n    };\n    let getIndex = o => {\n        var indexes = [], verticalMidpoint = b.x + (b.width / 2), horizontalMidpoint = b.y + (b.height / 2);\n        var startIsNorth = o.y < horizontalMidpoint, startIsWest = o.x < verticalMidpoint, endIsEast = o.x + o.width > verticalMidpoint, endIsSouth = o.y + o.height > horizontalMidpoint;\n        //top-right quad\n        if (startIsNorth && endIsEast) {\n            indexes.push(0);\n        }\n        //top-left quad\n        if (startIsWest && startIsNorth) {\n            indexes.push(1);\n        }\n        //bottom-left quad\n        if (startIsWest && endIsSouth) {\n            indexes.push(2);\n        }\n        //bottom-right quad\n        if (endIsEast && endIsSouth) {\n            indexes.push(3);\n        }\n        return indexes;\n    };\n    let split = _ => {\n        var next = lv + 1, width = b.width / 2, height = b.height / 2, x = b.x, y = b.y;\n        const make = (x, y) => (Quadtree({ x, y, width, height }));\n        //top right node\n        ns[0] = make(x + width, y);\n        //top left node\n        ns[1] = make(x, y);\n        //bottom left node\n        ns[2] = make(x, y + height);\n        //bottom right node\n        ns[3] = make(x + width, y + width);\n    };\n    let clear = _ => {\n        os = [];\n        for (let i = 0; i < ns.length; i++) {\n            if (ns.length) {\n                ns[i].clear();\n            }\n        }\n        ns = [];\n    };\n    return { insert, retrieve, getIndex, split, clear };\n};\n\n\n//# sourceURL=webpack:///./src/store.ts?");

/***/ })

/******/ });